# -*- coding: utf-8 -*-
"""
Created on Sun Feb 25 16:45:27 2024

@author: irawi
"""

# GOD THIS FILE SUCKS

import json
from math import floor, ceil
import urllib.request
import os 

enums = {}
enum_to_original_string = {}
key_enums_types = {} # stores the value type of enums that are used as keys (Atrs, Sets, AtreeItems, EffectKeys, etc) (ie, Atrs::Hp is an int, EffectKey::Parts is a list)
rename_enums = {"classReq" : "class","SpPct1Final" : "SpPct1", "SpPct2Final" : "SpPct2", "SpPct3Final" : "SpPct3", "SpPct4Final" : "SpPct4", 'TotalDamage' : 'Total', 'armour' : 'armor'}
dmg_types = ['n','e','t','w','f','a','r']
enums_files_imports = "use core::fmt;use crate::wynn_data::{WynnEnum,TryIntoWynnEnumError};use crate::enum_from_into;\n"
get_set = {} # given an item, returns the set

item_enums = []
set_enums = []
atree_enums = []

num_enum_strings_made = 0

iterable_types = [list, dict, tuple] # ignoring strings for now...

def cameltosnake(camel_string: str) -> str:
    # If the input string is empty, return an empty string
    if not camel_string:
        return ""
    # If the first character of the input string is uppercase, 
    # add an underscore before it and make it lowercase
    elif camel_string[0].isupper():
        return f"_{camel_string[0].lower()}{cameltosnake(camel_string[1:])}"
    # If the first character of the input string is lowercase, 
    # simply return it and call the function recursively on the remaining string
    else:
        return f"{camel_string[0]}{cameltosnake(camel_string[1:])}"
    
def camel_to_snake(s):
    if len(s)<=1:
        return s.lower()
    # Changing the first character of the input string to lowercase
    # and calling the recursive function on the modified string
    return cameltosnake(s[0].lower()+s[1:])

def upper_snake_to_camel(s):
    if not s:
        return s
    s2 = s.strip()
    s2 = s2.replace(' ',"_")
    s2 = ''.join([c for c in s2 if c.isalnum() or c=='_'])
    if "_" in s2:
        strs = s2.split("_")
        res = ""
        for s3 in strs:
            if len(s3)>0: res+=s3[0].upper()+s3[1::].lower()
        return res
    elif s2.isupper():
        return s2[0].upper()+s2[1::].lower()
    else:
        return s2[0].upper()+s2[1::]
    
def capitalize(s):
    return s[0].upper()+s[1::]
        
def get_skills(item, suffix="",default=0):
    return [item.get("str"+suffix,default),item.get("dex"+suffix,default),item.get("int"+suffix,default),item.get("def"+suffix,default),item.get("agi"+suffix,default)]

def compress_skills(sps):
    return ((sps[0] & 0xFFF)<<52 | (sps[1] & 0xFFF)<<39 | (sps[2] & 0xFFF)<<26 | (sps[3] & 0xFFF)<<13 | (sps[4] & 0xFFF)) - (0 if sps[0]>=0 else 18446744073709551616)

def parse_atr_data(atr, data):
    return (enums['Atrs'].index(atr)<<24) + (data & 0xFFFFFF)

def decode_atr_data(num):
    return (enums['Atrs'][num>>24],num&0xFFFFFF)

def add_enum(key, value):
    value_original = value
    if value=="": value="None"
    value = capitalize(upper_snake_to_camel(value))
    if value in rename_enums: value = rename_enums[value]
    if key in enums:
        if not value in enums[key]: 
            enums[key].append(value)
            enum_to_original_string[value]=value_original
    else:
        enums[key]=[value]
        enum_to_original_string[value]=value_original
    return (key,value)

def write_file(path, content):
    generated_files_header = "//! This file is autogenerated by rs_generator.py.<br>Code in this file uses wynncraft item data from [wynnbuilder's github repo](https://raw.githubusercontent.com/hppeng-wynn/hppeng-wynn.github.io/dev/data/2.0.4.3/items.json)\n"
    if not os.path.exists(path.rsplit('\\',1)[0]):
        print(f"\n\033[1;31mFile Path Error:\033[0;0m: {path} does not exist.\n")
        os.mkdir(path.rsplit('\\',1)[0])
    f = open(path, 'w', encoding='utf-8')                        
    try:
        f.write(generated_files_header+content)
    except Exception as e:
        print(f"\n\033[1;31m{str(type(e))}:\033[0;0m: {str(e)}\n")
    f.close()

def generate_enum(data,key,enum_name=None,ignore=[]):
    # print("Generating from",key)
    if not type(data)==dict:
        if type(data)==list:
            for i in range(len(data)):
                generate_enum(data[i],key,enum_name,ignore)
        return
    searching = key
    next_key = key
    at_root=True
    if '.' in key:
        split = key.split('.',1) if not key[0]=='*' else key.split('.',2)[1::]
        searching = split[0]
        if len(split)>1:
            at_root=False
            next_key = split[1]
    if searching=='':
        for k in data.keys():
            if not k in ignore: 
                tempk,tempv=add_enum(enum_name, k)
                # adds to key_enums_types
                if not tempk in key_enums_types:
                    key_enums_types[tempk]={}
                key_enums_types[tempk][tempv]=type(data[k])
    elif searching=='*':
        for k in data:
            generate_enum(data[k],next_key,enum_name,ignore)
    elif searching in data.keys():
        if at_root:
            if type(data[searching])==list and type(data[searching][0])==str:
                for s in data[searching]: 
                    if not s in ignore: add_enum(key if enum_name==None else enum_name, s)
            else:
                if not data[searching] in ignore: add_enum(key if enum_name==None else enum_name, data[searching])
        else: generate_enum(data[searching],next_key,enum_name,ignore)
    elif key[0]=='*':
        for k in data:
            generate_enum(data[k],key,enum_name,ignore)

def make_enum_string(enum_name, use_original_name_for_tostring = False):
    global num_enum_strings_made
    if not type(enums[enum_name][0])==str:
        print("Wrong type for making enum string:",enum_name,"with type",str(type(enum_name)))
    formatted_name = capitalize(upper_snake_to_camel(enum_name))
    formatted_values = [capitalize(upper_snake_to_camel(e.replace('\'',''))) for e in enums[enum_name]]
    adder = f"#[derive(Clone,Default,PartialEq,PartialOrd,Eq,Ord,Copy,Debug)]\npub enum "+formatted_name+"{#[default]"
    # generate enums
    adder += ",".join(formatted_values)+"}\n"
    # generates an iterator for the enums
    # adder += "impl "+formatted_name+"{pub const NUM_VARIENTS:usize="+str(len(formatted_values))+";"
    # adder += f"pub const VARIENTS:[Self;Self::NUM_VARIENTS]=[{','.join([f"Self::{fv}" for fv in formatted_values])}];"
    # adder+="pub fn iter() -> std::array::IntoIter<Self,"+str(len(formatted_values))+">{Self::VARIENTS.into_iter()}}\n"
    
    adder+=f"impl WynnEnum for {formatted_name}{{const VARIENTS:&'static[Self]=&[{','.join([f"Self::{fv}" for fv in formatted_values])}];const ENUM_TYPE_ID:u8={num_enum_strings_made};}}"
    num_enum_strings_made+=1
    # generates a tryfrom u8 for the enum
    if len(formatted_values)<256:
        base_enum_type = "u8"
    else:
        base_enum_type = "u16"
    adder += f"impl std::convert::TryFrom<{base_enum_type}> for "+formatted_name+f"{{type Error=TryIntoWynnEnumError<{base_enum_type},Self>;fn try_from(n: {base_enum_type}) -> Result<Self,Self::Error> {{match n{{"
    for i in range(len(formatted_values)):
        adder+=f"""{i} => Ok({formatted_name}::{formatted_values[i]}), """
    adder+="""_ => Err(TryIntoWynnEnumError{from: n, to: Self::default()})}}}\n"""

    # generates a display for the enum
    adder += "impl fmt::Display for "+formatted_name+"""{fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {write!(f,"{}",match self{"""
    for i in range(len(formatted_values)):
        adder+=f"""{formatted_name}::{formatted_values[i]} => "{enum_to_original_string[enums[enum_name][i]] if use_original_name_for_tostring and enums[enum_name][i] in enum_to_original_string else enums[enum_name][i]}", """ #String::from(
    adder+="})}}"
    # adder+=f"\nimpl WynnEnum for "+formatted_name+"{const VARIENTS:&'static[Self]=}"
    adder+=f"enum_from_into!("+formatted_name+f", {base_enum_type},u32,u64,i32,i64,usize);"
    return adder


def setup_general_enums():
    enums["class"] = ["Archer","Warrior","Mage","Assassin","Shaman"]
    enums["skill"] = ["Str","Dex","Int","Def","Agi"]
    enums["DamType"] = ["Neutral","Earth","Thunder","Water","Fire","Air","Rainbow"]
    global general_enums
    general_enums = ['class','DamType','skill']
    skill_impl = "\nimpl super::TryIntoI12x5Idx for Skill{type Error = String;fn try_into(self) -> Result<super::I12x5Idx, Self::Error> {Ok(match self{Self::Str => super::I12x5Idx::_0,Self::Dex => super::I12x5Idx::_1,Self::Int => super::I12x5Idx::_2,Self::Def => super::I12x5Idx::_3,Self::Agi => super::I12x5Idx::_4})}}"
    write_file('src\\wynn_data\\general\\enums.rs',enums_files_imports+'\n'.join([make_enum_string(s) for s in general_enums])+skill_impl)

def setup_item_enums(data):
    enums["tier"]=["Common","Unique","Rare","Legendary","Set","Fabled","Mythic"]
    # enums["atkSpd"]=["SUPER_SLOW","VERY_SLOW","SLOW","NORMAL","FAST","VERY_FAST","SUPER_FAST"]
    enums["atkSpd"]=["SuperSlow","VerySlow","Slow","Normal","Fast","VeryFast","SuperFast"]
    enums["type"]=["Helmet","Chestplate","Leggings","Boots","Ring","Bracelet","Necklace","Bow","Spear","Wand","Dagger","Relik"]
    generate_enum(data,'items.category','category')
    generate_enum(data,'items.restrict','restrict')
    generate_enum(data,'items.majorIds','majorIds')

    # all of the following is for generating the Atrs enum
    atrs_ignore = ["drop", "dropInfo", "armourColor", "skin", "armourMaterial", "armorType","lore", "quest", "set", "displayName","name","icon","spRegen","averageDps"] # todo: fix main attack range
    item_props = ['type','tier','lvl','category','id','fixID','atkSpd','slots','restrict','majorIds','allowCraftsman','classReq','set']
    # bad at naming things, these are elemental item stats that aren't identified (?). 
    # except reqs are properties, not stats (by my made up naming convention). idk.
    # todo: ele defs should be included here. 
    special_data = ["strReq","dexReq","intReq","defReq","agiReq","str","dex","int","def","agi","nDam","eDam","tDam","wDam","fDam","aDam"]
    stats = ['hp','eDef','tDef','wDef','fDef','aDef','damMult','defMult']
    ids = ['damRaw']
    ele_ids = []
    temp = unique_keys(data['items'],atrs_ignore+item_props+special_data+stats)
    for atr in temp:
        snake = camel_to_snake(atr)
        if not atr in ids and not atr in ele_ids:
            if snake[1]=='_' and snake[0] in dmg_types and not atr.endswith('Steal'):
                s = "ele_"+snake[2::]+"s"
                ele_ids.extend([dmg_type+atr[1::] for dmg_type in (dmg_types[1::] if "def" in s else dmg_types)])
            else:
                ids.append(atr)
    for t in dmg_types[0:6]: ele_ids.append(f"{t}AddDam")
    enums['Atrs'] = item_props+special_data+stats+sorted(ids)+ele_ids

    global item_enums
    item_enums = ['type','tier','category','atkSpd','restrict','majorIds','Atrs']
    global ele_prop_atrs
    ele_prop_atrs = special_data
    global stat_atrs
    stat_atrs=stats+sorted(ids)+ele_ids
    atrs_docs = "/// Used to identify almost all types of data stored in wynncraft items. \n///\n/// The following item attributes are ignored due to them either taking up a lot of memory or just not being useful for my application:\n/// - `drop`\n/// - `dropInfo`\n/// - `armorColor`\n/// - `skin`\n/// - `material` \n/// - `armorType`\n/// - `lore`\n/// - `quest`\n/// # Naming Convention\n/// **Attributes** - (Almost) all data stored in wynncraft items<br>\n/// **Properties** - Data intrinsic to items that don't get counted when calculating a build's stats. ie: `Type`, `Tier`, `ClassReq`, etc...<br>\n/// **Stats** - All data used for calculating a build's stats, including all *identifications*, hp, and ele defs. Damages, skill reqs, and skill bonuses are not included. <br>\n/// **Identifications** - All item *attributes* which are determined when identifying an item. These stats vary based on `WynnItem.quality`, unless `Atrs::FixID` is true. "
    # consts=f"/// Total number of item attributes. Attributes include all stats and most of the other item properties (rarity, category, etc)\n///\n/// See enums::Atrs for more info\npub const NUM_ITEM_ATRS: usize = {len(enums['Atrs'])};\n"
    consts=f"/// Total number of item properties. Properties include most non-addable attributes of an item (rarity, category, etc)<br>See enums::Atrs for more info\npub const NUM_PROPS: usize = {len(item_props)};\n"
    consts+=f"/// Total number of item stats. Includes all standard identifications, in addition to things such as elemental defs<br>See enums::Atrs for more info\npub const NUM_STATS: usize = {len(stat_atrs)};\n"
    consts+=f"/// Total number of elemental stats.<br>See enums::Atrs for more info\npub const NUM_ELE_STATS: usize = {len(ele_ids)};\n"
    consts+=f"/// Simply `NUM_VARIENTS - NUM_STATS`<br>See `NUM_VARIENTS`, `NUM_STATS`, and `items::enums::Atrs` for more info\npub const NUM_NON_STATS: usize = {len(enums['Atrs'])-len(stat_atrs)};\n"
    consts+=f"/// Total number of identifications.<br>See `items::enums::Atrs` for more info\npub const NUM_IDS: usize = {len(ids)+len(ele_ids)};\n"
    consts+=f"/// `NUM_VARIENTS - NUM_IDS`<br>See `items::enums::Atrs` for more info\npub const NUM_NON_IDS: usize = {len(enums['Atrs'])-len(ids)-len(ele_ids)};\n"
    write_file('src\\wynn_data\\items\\enums.rs',enums_files_imports+'\n'.join([(f"{atrs_docs}\n" if n=='Atrs' else '')+make_enum_string(n) for n in item_enums])+f"impl Atrs{{{consts}}}")

def get_enum_with_value(value,ignore=[]):
    v2 = capitalize(upper_snake_to_camel(value))
    res = []
    for e in enums:
        if not e in ignore and (value in enums[e] or v2 in enums[e]): res.append(e)
    return res

def parse_data(value, *, key = None, ret_len_if_list = False, ignore_enums = []):
    key_formatted = upper_snake_to_camel(key)
    if key in rename_enums or key_formatted in rename_enums:
        key=rename_enums[key if key in rename_enums else key_formatted]
    if type(value)==int:
        return value
    elif type(value)==float:
        return int(value*100) # scuffed
    elif type(value)==tuple and len(value)==2 and type(value[0])==int and type(value[1])==int:
        return ((value[0]&0xFFF)<<12) | (value[1]&0xFFF)
    elif type(value)==str:
        if value.isnumeric(): return int(value)
        if value.split("-",1)[0].isnumeric():
            temp = value.split("-",1)
            return ((int(temp[0])&0xFFF)<<12) | (int(temp[1])&0xFFF)
        value = capitalize(upper_snake_to_camel(value)) if not value=="" else 'None'
        if value in rename_enums: value = rename_enums[value]
        if not key==None and value in enums[key]:
            return enums[key].index(value)
        else:
            for k in enums:
                if k in ignore_enums: continue
                for i in range(len(enums[k])):
                    if enums[k][i].upper()==value.upper():
                        # print("found",value,"at index",i,"in",k)
                        return i
            print("Error parsing data",value,"with key",key)
    elif type(value)==list:
        if len(value)==0:
            return 0
        if ret_len_if_list:
            return len(value)
        elif len(value)==1 and not key==None:
            if value[0] in enums[key]:
                return enums[key].index(value[0])
    elif type(value)==dict and ret_len_if_list:
        return len(value)
    elif type(value)==bool:
        return 0 if value==False else 1
    else:
        print("Failed to parse",value,"with type",str(type(value)))
    return 0

def setup_set_enums(data):
    enums['sets']=["None"]
    enums['sets'].extend([st for st in data['sets']])
    global set_enums
    set_enums = ['sets']
    global get_set
    for st in data['sets']: 
        for item in data['sets'][st]['items']: get_set[item] = st
    write_file('src\\wynn_data\\sets\\enums.rs',enums_files_imports+make_enum_string('sets'))
    
def setup_set_data(data):
    limit=10000
    set_bonuses = ["&[]"]
    # get_set={}
    for st in data['sets']:
        bonuses = []
        # for itm in data['sets'][st]['items']:
        #     get_set[itm]=upper_snake_to_camel(st)
        for b in data['sets'][st]['bonuses']:
            b_ids = {}
            for key, value in b.items():
                real_key = 'fixID' if key=='illegal' else 'spd' if key=='ws' else key
                b_ids[real_key]=parse_atr_data(real_key,parse_data(value,key=real_key))
            bonuses.append("("+str(compress_skills(get_skills(b)))+", &["+','.join([str(b_ids[i]) for i in enums['Atrs'] if i in b_ids])+"])")
        set_bonuses.append("&["+','.join(bonuses)+"]")
        limit-=1
        if limit<=0: break
    gen_set_bonuses_const = "pub const SET_BONUSES: &'static[&'static [(i64,&'static [u32])]] = &["+',\n'.join(set_bonuses)+"];"
    write_file('src\\wynn_data\\sets\\set_bonus_data.rs',gen_set_bonuses_const)
    
def setup_item_data(data):
    counter = 0
    wynn_items=[]
    all_item_names=[]
    for d in data['items']:
        struct_data = {}
        partitions = [0,0,0,0]
        for k, v in d.items():            
            if not k in enums['Atrs'] or k=='set' or v=='0-0': continue
            if k=='tier' and (v=='Set' or d['name'] in get_set): # weird wonkyness because GM's boots? wtf is this item even?
                if d['name'] in get_set or d['displayName'] in get_set: struct_data['set']=parse_atr_data('set',enums['sets'].index(get_set[d['name' if d['name'] in get_set else 'displayName']]))
                # (enums['Atrs'].index('set')<<24)+enum_builder['sets'][1].index(get_set[d['name' if d['name'] in get_set else 'displayName']])
            struct_data[k] = parse_atr_data(k,parse_data(v,key=k))
        idx = 0
        num_props = 0
        partition_counter = [0,0,0]
        for x in enums['Atrs']:
            if x in struct_data:
                if x in ele_prop_atrs:
                    if num_props==0: num_props=idx
                    if x in ele_prop_atrs[0:5]: partition_counter[0]+=1
                    elif x in ele_prop_atrs[5:10]: partition_counter[1]+=1
                    elif x in ele_prop_atrs[10:16]: partition_counter[2]+=1
                elif x in stat_atrs: break
                idx+=1
        if num_props==0: num_props=idx
        partitions[0]=num_props
        for i in range(len(partition_counter)):
            partitions[i+1]=partitions[i]+partition_counter[i]
        wynn_items.append('&super::WynnItemData{name: "'+d['displayName']+f'", sps_req_data: {compress_skills(get_skills(d, "Req", -1024))}, sps_bonus_data: {compress_skills(get_skills(d))}, partitions: ({",".join([str(n) for n in partitions])}), data: &['+','.join([str(struct_data[x]) for x in enums['Atrs'] if x in struct_data])+"]}")
        
        parsed_const_name = ''.join([c if c.isalnum() or c==' ' else ' ' if c=='-' else '' for c in d['displayName']])
        is_duplicate = False
        for _,name in all_item_names:
            if parsed_const_name.upper()==name.upper(): 
                is_duplicate=True
                break
        if not is_duplicate:
            all_item_names.append((counter,parsed_const_name))
        
        counter += 1
        if counter>=10000: break

    gen_items_const = """pub const ALL_ITEMS: &'static[&'static super::WynnItemData] = &[&super::WynnItemData{name: "Invalid Item", sps_req_data: 0, sps_bonus_data: 0, partitions: (0,0,0,0), data:&[]},"""+',\n'.join(wynn_items)+"];"
    
    item_from_name_matcher = f"#![allow(unused)]\nimpl super::WynnItem{{{''.join([f'pub const {all_item_names[i][1].upper().replace(' ','_')}: Self = Self::from_idx({all_item_names[i][0]+1});{'\n' if i%20==0 else ''}' for i in range(len(all_item_names))])}}}"
    item_from_name_matcher += f"\nuse super::WynnItem;\n#[macro_export]\nmacro_rules! item_from_tt({''.join([f'({all_item_names[i][1]}) => {{WynnItem::{all_item_names[i][1].upper().replace(' ','_')}}};{'\n' if i%50==0 else ''}' for i in range(len(all_item_names))])});"

    write_file('src\\wynn_data\\items\\items_list.rs',gen_items_const)
    write_file('src\\wynn_data\\items\\item_consts.rs',item_from_name_matcher)
    
def unique_keys(data,ignore=[]):
    res = []
    if type(data)==dict:
        for key in data.keys():
            if not key in res and not key in ignore:
                res.append(key)
    elif type(data)==list and type(data[0])==dict:
        for d in data:
            for key in d.keys():
                if not key in res and not key in ignore:
                    res.append(key)
    else:
        print("unique_keys() called on non-dict or list type")
    return res

def sort_keyenums_by_type(keyenum, ordered_types):
    if not keyenum in key_enums_types:
        print("Keyenum",keyenum,"not found in key_enums_types")
        return
    res = {t : [] for t in ordered_types}
    if not 'any' in res:
        res['any']=[]
    for k,itm in key_enums_types[keyenum].items():
        if not itm in res:
            res['any'].append(k)
        else:
            res[itm].append(k)
    curr=0
    for t in ordered_types:
        for i in range(len(res[t])):
            enums[keyenum][curr]=res[t][i]
            curr+=1


class AtreeItem:
    def __init__(self, data):
        self.name=data['display_name']
        self.effects=[]
        if 'effects' in data:
            for effect in data['effects']:
                effect_data = []
                if 'type' in effect:
                    effect_data.append(enums['EffectType'].index(effect['type']))
                if 'cost' in effect and 'base_spell' in effect:
                    effect_data.append(parse_atr_data(f"spRaw{effect['base_spell']}",effect['cost']))
                self.effects.append(effect_data)

def setup_atree(data,for_wynn_class=None):
    if for_wynn_class==None:
        generate_enum(data,"*.*.","AtreeKey",['req_archetype','desc','display','__TODO'])
        print("AtreeKeys",enums['AtreeKey'])

        enums['Archetype']=['None']
        generate_enum(data,"*.archetype","Archetype")
        print("Archetypes:",enums['Archetype'])

        generate_enum(data,"*.effects.","EffectKey",['display','spell_type'])
        sort_keyenums_by_type('EffectKey',['any',list,tuple,dict])
        print("EffectKeys:",enums['EffectKey'])
    
        generate_enum(data,"*.effects.type","EffectType")
        print("EffectTypes:",enums['EffectType'])

        generate_enum(data,"*.effects.bonuses.type","BonusType")
        enums['BonusType']=["Stat","Prop"]
        print("BonusTypes:",enums['BonusType'])

        generate_enum(data,"*.effects.parts.","EffectPartKey",['display'])
        sort_keyenums_by_type('EffectPartKey',['any',list,tuple,dict])
        print("EffectPartKeys:",enums['EffectPartKey'])

        generate_enum(data,"*.effects.parts.type","EffectPartType")
        print("EffectPartTypes:",enums['EffectPartType'])

        general_atree_enums = ['AtreeKey','Archetype','EffectKey','EffectType','BonusType','EffectPartKey','EffectPartType']

        write_file(f'src\\wynn_data\\atree\\enums.rs',enums_files_imports+'\n'.join([make_enum_string(n) for n in general_atree_enums]))

        for wynn_class in data:
            setup_atree(data[wynn_class],for_wynn_class=wynn_class)
        return

    enums['AtreeItems']=[]
    generate_enum(data,"*.display_name","AtreeItems")
    print("AtreeItems:",enums['AtreeItems'])

    enums['Prop']=[]
    generate_enum(data,"*.properties.","Prop")
    print("Props",enums['Prop'])

    enums['Spell']=['Melee']
    generate_enum(data,"*.effects.name","Spell")
    print("Spells:",enums['Spell'])

    enums['SpellPart']=["None","Total","Dps","TotalDps"]
    generate_enum(data,"*.effects.parts.name","SpellPart")
    generate_enum(data,"*.effects.target_part","SpellPart")
    print("SpellParts:",enums['SpellPart'],len(enums['SpellPart']))

    global atree_enums
    atree_enums = ['AtreeItems','AtreeKey','Archetype','Prop','EffectKey','Spell','EffectType','BonusType','SpellPart','EffectPartKey','EffectPartType']
    class_specific_atree_enums = ['AtreeItems','Prop','Spell','SpellPart']
    write_file(f'src\\wynn_data\\atree\\{for_wynn_class.lower()}\\mod.rs','pub (super) mod atree_data;'+enums_files_imports+'\n'.join([make_enum_string(n, n=="AtreeItems") for n in class_specific_atree_enums]))

    parsed_data = []
    for atree_item in data:
        if not 'properties' in atree_item:
            print(atree_item['display_name'],"does not have key 'properties' ??")
            atree_item['properties']=[]
        parents = setup_file_from_data(atree_item['parents'],False)
        deps = setup_file_from_data(atree_item['dependencies'],False)
        blockers = setup_file_from_data(atree_item['blockers'],False)
        props = setup_file_from_data(atree_item['properties'],False)
        effects = []
        for e in atree_item['effects']:
            temp=setup_file_from_data(e,False,[['AtreeKey','AtreeItems','EffectPartType'],['AtreeKey','EffectType','Spell','EffectKey','AtreeItems'],['AtreeKey','EffectType','Spell','EffectKey','AtreeItems']],['behavior'],{'target_part' : "SpellPart"})
            effects.append(f"&[{','.join([str(n) for n in temp])}]")
        data = setup_file_from_data(atree_item,False,[],['parents','dependencies','blockers','properties','effects','desc','req_archetype','display','__TODO'])
        appender = "&AtreeItemData{name:\""+atree_item['display_name']
        appender+='",parents:&['+','.join([str(n) for n in parents])
        appender+='],deps:&['+','.join([str(n) for n in deps])
        appender+='],blockers:&['+','.join([str(n) for n in blockers])
        appender+='],props:&['+','.join([str(n) for n in props])
        appender+='],effects:&['+','.join([str(n) for n in effects])
        appender+='],data:&['+','.join([str(n) for n in data])
        appender+=f'],enum_id:AtreeItems::{capitalize(upper_snake_to_camel(atree_item['display_name']))}}}'
        parsed_data.append(appender)
    gen_atree_data = f"pub const ATREE_DATA: &'static[&'static AtreeItemData<{for_wynn_class}AtreeEnums>] = &["+',\n'.join(parsed_data)+"];"
    write_file(f'src\\wynn_data\\atree\\{for_wynn_class.lower()}\\atree_data.rs',f'use super::{{AtreeItems,super::{{AtreeItemData,{for_wynn_class}AtreeEnums}}}};\n'+gen_atree_data)


def setup_file_from_data(data,ignore_empty=False,ignore_enums=[],ignore_keys=[],use_enum_for_data_key={}):
    res=[]
    ignore = ignore_enums
    recursive_ignores = False
    if type(ignore_enums)==list and len(ignore_enums)>0 and type(ignore_enums[0])==list:
        ignore = ignore_enums[0]
        recursive_ignores=True
    if type(data)==list:
        for d in data:
            if type(d)==dict:
                res.extend(setup_file_from_data(d,ignore_empty,ignore_enums[1::] if recursive_ignores else ignore_enums))
            else:
                temp = parse_data(d,ignore_enums=ignore)
                res.append(temp if temp >= 0 else temp & 0xFFFFFFFF)
        return res
    unsorted_res = {}
    for key,value in data.items():
        if ignore_empty and (type(value)==dict or type(value)==list) and len(value)==0:
            continue
        if key in ignore_keys:
            continue
        temp = get_enum_with_value(key,ignore)
        if len(temp)==0:
            continue
        while len(temp)>1 and parse_data(key,ignore_enums=ignore,key=temp[0]) in unsorted_res.keys(): # safety check for overriding keys (assume we don't want to override)
            temp.pop(0)
        # print("Parsing",key,value,"as",parse_data(key,ignore_enums=ignore,key=temp[0]),parse_data(value,ignore_enums=ignore,ret_len_if_list=True))
        parsed = (parse_data(key,ignore_enums=ignore,key=temp[0])<<24) + (parse_data(value,ignore_enums=ignore,key=use_enum_for_data_key[key] if key in use_enum_for_data_key else None,ret_len_if_list=True) & 0xFFFFFF)
        
        # res.append(parsed)
        unsorted_res[parsed >> 24] = [parsed]        
        if (type(value)==list or type(value)==dict) and len(value)>0:
            temp = setup_file_from_data(value,ignore_empty,ignore_enums[1::] if recursive_ignores else ignore_enums)
            unsorted_res[parsed >> 24] = [(parsed>>24<<24)+len(temp)]
            unsorted_res[parsed >> 24].extend(temp)
    for key in sorted(unsorted_res):
        res.extend(unsorted_res[key])
    return res

def reparse_atree_data(data):
    for clas in data:
        for abil in data[clas]:
            if 'effects' in abil:
                for effect in abil['effects']:
                    if effect['type']=='raw_stat' and 'bonuses' in effect:
                        i=0
                        while i < len(effect['bonuses']):
                            bonus = effect['bonuses'][i]
                            if bonus['name'].endswith('DamAddMin'):
                                found_add = False
                                for j in range(i):
                                    if effect['bonuses'][j]['name'].endswith('AddDam'):
                                        effect['bonuses'][j]['value']+=bonus['value']<<12
                                        found_add = True
                                        del effect['bonuses'][i]
                                        break
                                if not found_add:
                                    bonus['name']=bonus['name'][0]+'AddDam'
                                    bonus['value']=bonus['value']<<12
                                    i+=1
                            elif bonus['name'].endswith('DamAddMax'):
                                found_add = False
                                for j in range(i):
                                    if effect['bonuses'][j]['name'].endswith('AddDam'):
                                        effect['bonuses'][j]['value']+=bonus['value']
                                        found_add = True
                                        del effect['bonuses'][i]
                                        break
                                if not found_add:
                                    bonus['name']=bonus['name'][0]+'AddDam'
                                    bonus['value']=bonus['value']
                                    i+=1
                            else:
                                i+=1
                        i=0
                        while i < len(effect['bonuses']):
                            bonus = effect['bonuses'][i]
                            abil = bonus['abil'] if 'abil' in bonus else bonus['name'].split('.')[-1] if bonus['name'].startswith('damMult') else ''
                            effect['bonuses'][i] = {bonus['type'] : abil, bonus['name'] if not '.' in bonus['name'] else bonus['name'].split('.')[0] : bonus['value']}
                            i+=1
    # print(atree_items["Archer"])

# check https://api.wynncraft.com/v3/item/database?fullResult for updates to item data
def reparse_updated_item_database(correctdata, wynnbuilderdata):
    res = dict(correctdata)
    for key,value in correctdata.items():
        if not "type" in value or value['type'] not in ['armour','accessory','weapon']:
            del res[key]
    
    # 'type','tier','lvl','category','id','fixID','atkSpd','slots','restrict','majorIds','allowCraftsman','classReq','set'
    # not parsing set because idk if api.wynncraft has set data?
    prop_renames = {'type' : 'category', 'rarity' : 'tier', 'weaponType' : 'type', 'armourType': 'type', 'accessoryType' : 'type', 'attackSpeed':'atkSpd', 'powderSlots':'slots', 'identified': 'fixID'}
    
    req_renames = {'level': 'lvl', 'strength': 'strReq', 'dexterity': 'dexReq','intelligence': 'intReq', 'defence': 'defReq', 'agility': 'agiReq'}
    
    # Str,Dex,Int,Def,Agi,NDam,EDam,TDam,WDam,FDam,ADam,Hp,EDef,TDef,WDef,FDef,ADef,DamMult,DefMult,AtkTier,DamRaw,ESteal,Expd,HealPct,HpBonus,HprPct,HprRaw,Jh,Kb,Lb,Ls,MdPct,MdRaw,Mr,Ms,Poison,Ref,SdPct,SdRaw,SlowEnemy,SpPct1,SpPct2,SpPct3,SpPct4,SpRaw1,SpRaw2,SpRaw3,SpRaw4,SpRegen,
    # Spd,Sprint,SprintReg,Thorns,WeakenEnemy,Xpb,NDamPct,EDamPct,TDamPct,WDamPct,FDamPct,ADamPct,RDamPct,EDefPct,TDefPct,WDefPct,FDefPct,ADefPct,RDefPct,NSdRaw,ESdRaw,TSdRaw,WSdRaw,FSdRaw,ASdRaw,RSdRaw,NSdPct,ESdPct,TSdPct,WSdPct,FSdPct,ASdPct,RSdPct,NMdRaw,EMdRaw,TMdRaw,WMdRaw,FMdRaw,AMdRaw,RMdRaw,NDamRaw,EDamRaw,TDamRaw,WDamRaw,FDamRaw,ADamRaw,RDamRaw,NMdPct,EMdPct,TMdPct,WMdPct,FMdPct,AMdPct,RMdPct
    id_renames = {'rawStrength' : 'str','rawDexterity' : 'dex','rawIntelligence' : 'int','rawDefence':'def','rawAgility':'agi',
                  'baseHealth' : 'hp', 'rawAttackSpeed' : 'atkTier', 'rawDamage' : 'damRaw', 'stealing' : 'eSteal', 'exploding' : 'expd', 'healingEfficiency' : 'healPct', 'rawHealth' : 'hpBonus',
                  'healthRegen' : 'hprPct', 'healthRegenRaw' : 'hprRaw', 'jumpHeight' : 'jh', 'knockback': 'kb', 'lootBonus': 'lb', 'lifeSteal' : 'ls', 'rawMainAttackDamage' : 'mdRaw',
                  'mainAttackDamage' : 'mdPct', 'manaRegen' : 'mr', 'manaSteal' : 'ms', 'poison' : 'poison', 'reflection' : 'ref', 'rawSpellDamage' : 'sdRaw', 'spellDamage' : 'sdPct', 'slowEnemy' : 'slowEnemy', 
                  '1stSpellCost' : 'spPct1','2ndSpellCost' : 'spPct2','3rdSpellCost' : 'spPct3','4thSpellCost' : 'spPct4','raw1stSpellCost' : 'spRaw1','raw2ndSpellCost' : 'spRaw2','raw3rdSpellCost' : 'spRaw3','raw4thSpellCost' : 'spRaw4',
                  'walkSpeed' : 'spd', 'sprint' : 'sprint', 'sprintRegen' : 'sprintReg', 'thorns' : 'thorns', 'weakenEnemy' : 'weakenEnemy', 'xpBonus' : 'xpb', 'neutralDamage' : 'nDamPct', 
                  'earthDamage': 'eDamPct', 'damage' : ['mdPct', 'sdPct'], 'baseDamage' : 'nDam', 'mainAttackRange' : 'mainAtkRange', 'rawMaxMana' : 'maxMana', 'criticalDamageBonus' : 'critDamPct'} # mainatkrange rawmaxmana maxmana added. what are these?
    ele_id_renames = {'base*Defence':'*Def', 'base*Damage' : '*Dam','*Damage' : '*DamPct', 'raw*Damage' : '*DamRaw', '*Defence' : '*DefPct', 'raw*SpellDamage' : '*SdRaw', '*SpellDamage' : '*SdPct', 'raw*MainAttackDamage' : '*MdRaw', '*MainAttackDamage' : '*MdPct'}
    elements = {'neutral':'n', 'earth':'e', 'thunder':'t', 'water':'w', 'fire':'f', 'air':'a', 'elemental' : 'r'}
    for key, value in ele_id_renames.items():
        for e1,e2 in elements.items(): id_renames[key.replace('*',e1 if key[0]=='*' else capitalize(e1))]=value.replace('*',e2)
    
    # update wynnbuilder item data if it is partially out of date
    res2 = []
    added_items = {}
    max_id_found = 0
    for itm in wynnbuilderdata['items']:
        if itm['displayName'] in res or itm['name'] in res:
            itm_name = itm['name'] if itm['name'] in res else itm['displayName']
            if 'identifications' in res[itm_name].keys():
                for k,v in res[itm_name]['identifications'].items():
                    value = v['raw'] if type(v)==dict else v
                    if k in id_renames:
                        if type(id_renames[k])==list:
                            for ident_key in id_renames[k]:
                                itm[ident_key]=value
                        else:
                            itm[id_renames[k]]=value
                    else:
                        print("Could not find ident rename for",k)
                        exit(1)
            if 'base' in res[itm_name].keys():
                for k,v in res[itm_name]['base'].items():
                    value = f"{v['min']}-{v['max']}" if type(v)==dict and k.endswith('Damage') else v
                    if k in id_renames:
                        if type(id_renames[k])==list:
                            for ident_key in id_renames[k]:
                                itm[ident_key]=value
                        else:
                            itm[id_renames[k]]=value
                    else:
                        print("Could not find base rename for",k)
                        exit(1)
            if 'requirements' in res[itm_name].keys():
                for k,v in res[itm_name]['requirements'].items():
                    value = v['raw'] if type(v)==dict else v
                    if k in req_renames:
                        itm[req_renames[k]]=value
            if 'id' in itm.keys() and itm['id']>max_id_found: max_id_found = itm['id']
            res2.append(itm)
            added_items[itm_name.upper()]=1
    # add new items not yet in wynnbuilder
    for name in res.keys():
        if not name.upper() in added_items:
            itm_ref = res[name]
            itm={}
            itm['displayName']=name
            itm['name']=itm_ref['internalName']
            for k,v in itm_ref.items():
                if k in prop_renames:
                    itm[prop_renames[k]]=v
            if 'identifications' in itm_ref.keys():
                for k,v in itm_ref['identifications'].items():
                    value = v['raw'] if type(v)==dict else v
                    if k in id_renames:
                        if type(id_renames[k])==list:
                            for ident_key in id_renames[k]:
                                itm[ident_key]=value
                        else:
                            itm[id_renames[k]]=value
                    else:
                        print("Could not find ident rename for",k)
                        exit(1)
            if 'base' in itm_ref.keys():
                for k,v in itm_ref['base'].items():
                    value = f"{v['min']}-{v['max']}" if type(v)==dict and k.endswith('Damage') else v
                    if k in id_renames:
                        if type(id_renames[k])==list:
                            for ident_key in id_renames[k]:
                                itm[ident_key]=value
                        else:
                            itm[id_renames[k]]=value
                    else:
                        print("Could not find base rename for",k)
                        exit(1)
            if 'requirements' in itm_ref.keys():
                for k,v in itm_ref['requirements'].items():
                    value = v['raw'] if type(v)==dict else v
                    if k in req_renames:
                        itm[req_renames[k]]=value
            max_id_found+=1
            itm['id']=max_id_found
            res2.append(itm)
            added_items[name]=1
    for itm in res2:
        if not 'type' in itm.keys() or not 'tier' in itm.keys() or not 'lvl' in itm.keys() or not 'category' in itm.keys() or not 'id' in itm.keys():
            print(itm)
            exit(1)
    return res2

if __name__=='__main__':
    # f = open('items.json', 'r', encoding='utf-8')
    try:
        page = urllib.request.Request("https://api.wynncraft.com/v3/item/database?fullResult",headers={'User-Agent': 'Mozilla/5.0'})
        f=urllib.request.urlopen(page)
        fstring = f.read().decode('ISO-8859-1')
    except urllib.error.HTTPError as e:
        print(e)
    try:
        data1 = json.loads(fstring)
    except Exception as e:
        print(f"\n\033[1;31mError loading file: \033[93m{str(type(e))}:\033[0;0m {str(e)}\n")
    f.close()
    
    f = urllib.request.urlopen("https://raw.githubusercontent.com/hppeng-wynn/hppeng-wynn.github.io/refs/heads/dev/data/2.1.1.3/items.json")
    try:
        data = json.load(f)
        for item in data['items']:
            item.pop('mainAttackRange', None)
    except Exception as e:
        print(f"\n\033[1;31mError loading file: \033[93m{str(type(e))}:\033[0;0m {str(e)}\n")
    f.close()
    
    data['items'] = reparse_updated_item_database(data1, data)

    # temporary fix for soul point regen being removed
    for st in data['sets']:
        for d in data['sets'][st]['bonuses']:
            d.pop('spRegen',None)
            if 'hpbonus' in d:
                d['hpBonus'] = d['hpbonus']
                d.pop('hpbonus', None)

    # construct_items_rust(data, False)
    

    setup_general_enums()
    setup_item_enums(data)
    setup_set_enums(data)

    setup_item_data(data)
    setup_set_data(data)
    
    f = urllib.request.urlopen("https://raw.githubusercontent.com/hppeng-wynn/hppeng-wynn.github.io/refs/heads/dev/data/2.1.1.3/atree.json")
    try:
        data = json.load(f)
    except Exception as e:
        print(f"\n\033[1;31mError loading file: \033[93m{str(type(e))}:\033[0;0m {str(e)}\n")
    f.close()

    reparse_atree_data(data)
    setup_atree(data)

    tster = []
    replace_spell_data = []
    tster2 = []
    for cls in data:
        for atreeitm in data[cls]:
            for eff in atreeitm['effects']:
                for k in eff:
                    if not k in tster2 and (type(eff[k])==list or type(eff[k])==tuple or type(eff[k])==dict):
                        tster2.append(k)
                counter = 0
                # if eff['type']=='raw_stat' and 'bonuses' in eff:
                #     print(eff['bonuses'])
                if eff['type']=='replace_spell':
                    for k in eff:
                        if len(replace_spell_data)<=counter:
                            replace_spell_data.append([])
                        if not k in replace_spell_data[counter]:
                            replace_spell_data[counter].append(k)
                        counter+=1
                if not eff['type']=='add_spell_prop': continue
                counter = 0
                for k in eff:
                    if len(tster)<=counter:
                        tster.append([])
                    if not k in tster[counter]:
                        tster[counter].append(k)
                    if k=='name': print(eff['name'])
                    counter+=1
    print("add_spell_props",tster)
    print("iterable effect keys:",tster2)
    print("replace_spells",replace_spell_data)

    # generate_enum(data,'*.effects.name','AtreeSpells')
    # print("#####")
    # print(make_enum_string('AtreeSpells'))
    # write_file("src\\wynn_data\\atree\\enums.rs",enums_files_imports+make_enum_string('AtreeSpells'))
    # print([upper_snake_to_camel(e) for e in enums['AtreeSpells']])


# quoted from salted 
# Spell Damage Conversion now applies to ALL of your damage types. In 1.20 and earlier, it used to only apply to Neutral Damage. So for example, if your weapon deals 50 Water Damage and you cast a spell that has 100% Neutral and 50% Fire damage, you will end up dealing 50 Water Damage + 25 Fire Damage
# Spell Damage Conversion is also not a conversion anymore, but simply adds damage directly. Previously, 20% Water Conversion on a spell meant it would take away 20% of your damage and transform it into Water. In 2.0, it simply adds 20% more Water Damage. This change is to make spell damage easier to understand.
# There is now a third damage bonus type, only found in Ability Trees called Additive Damage. It is added as pure damage not affected by your spell attack speed modifier before item bonuses kick in. Contrary to Raw, it is not modified by your spell damage multiplier. This means that fast attack abilities are more affected by it.
# Raw Damage is now added proportionally to ALL of your damage types. Previously, it used to add the damage as flat Neutral Damage. In 2.0, it will be spread to all neutral + elemental damage you deal. So for example, if you deal 50 Neutral Damage and 100 Water Damage, and have +60 Raw Damage, you will end up dealing 70 Neutral and 140 Water Damage.
# We've added new elemental-only Raw Damage as well. They aren't used on any item yet, but they may in the future. These raw damages only get added if you deal that particular elemental damage as your base damage. So for example, if you deal 50 Fire Damage and have +10 Water Raw Damage, nothing will happen. But if you cast a water spell, the +10 Damage will get applied.

# These last two changes were how raw damage was meant to work since Gavel, but the system wasn't flexible enough to allow it. Now, both % and raw damage work in a similar manner. While playing normally, you may feel like mobs' elemental defences and weaknesses matter more than they used to.
    
# print(get_items_with_data("eSdPct"))
# print(get_items_with_data("majorIds"))
    
# construct_items_rust()

# https://forums.wynncraft.com/threads/2-0-spellbound-changelog.299715/

#Agility will not fully nullify damage when triggered anymore. Instead, it will deal 10% of the damage to you and deal no knockback. Its scaling is slightly higher than defence, but they are both effectively equal.