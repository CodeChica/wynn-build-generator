# -*- coding: utf-8 -*-
"""
Created on Sun Feb 25 16:45:27 2024

@author: irawi
"""

# GOD THIS FILE SUCKS

import json
from math import floor, ceil
import urllib.request
import os 

enums = {}
enum_to_original_string = {}
key_enums_types = {} # stores the value type of enums that are used as keys (Atrs, Sets, AtreeItems, EffectKeys, etc) (ie, Atrs::Hp is an int, EffectKey::Parts is a list)
rename_enums = {"classReq" : "class","SpPct1Final" : "SpPct1", "SpPct2Final" : "SpPct2", "SpPct3Final" : "SpPct3", "SpPct4Final" : "SpPct4", 'TotalDamage' : 'Total'}
dmg_types = ['n','e','t','w','f','a','r']
enums_files_imports = "use core::fmt;use crate::wynn_data::{WynnEnum,TryIntoWynnEnumError};use crate::enum_from_into;\n"
get_set = {} # given an item, returns the set

item_enums = []
set_enums = []
atree_enums = []

num_enum_strings_made = 0

iterable_types = [list, dict, tuple] # ignoring strings for now...

def cameltosnake(camel_string: str) -> str:
    # If the input string is empty, return an empty string
    if not camel_string:
        return ""
    # If the first character of the input string is uppercase, 
    # add an underscore before it and make it lowercase
    elif camel_string[0].isupper():
        return f"_{camel_string[0].lower()}{cameltosnake(camel_string[1:])}"
    # If the first character of the input string is lowercase, 
    # simply return it and call the function recursively on the remaining string
    else:
        return f"{camel_string[0]}{cameltosnake(camel_string[1:])}"
    
def camel_to_snake(s):
    if len(s)<=1:
        return s.lower()
    # Changing the first character of the input string to lowercase
    # and calling the recursive function on the modified string
    return cameltosnake(s[0].lower()+s[1:])

def upper_snake_to_camel(s):
    if not s:
        return s
    s2 = s.strip()
    s2 = s2.replace(' ',"_")
    s2 = ''.join([c for c in s2 if c.isalnum() or c=='_'])
    if "_" in s2:
        strs = s2.split("_")
        res = ""
        for s3 in strs:
            if len(s3)>0: res+=s3[0].upper()+s3[1::].lower()
        return res
    elif s2.isupper():
        return s2[0].upper()+s2[1::].lower()
    else:
        return s2[0].upper()+s2[1::]
    
def capitalize(s):
    return s[0].upper()+s[1::]
        
def get_skills(item, suffix="",default=0):
    return [item.get("str"+suffix,default),item.get("dex"+suffix,default),item.get("int"+suffix,default),item.get("def"+suffix,default),item.get("agi"+suffix,default)]

def compress_skills(sps):
    return ((sps[0] & 0xFFF)<<52 | (sps[1] & 0xFFF)<<39 | (sps[2] & 0xFFF)<<26 | (sps[3] & 0xFFF)<<13 | (sps[4] & 0xFFF)) - (0 if sps[0]>=0 else 18446744073709551616)

def parse_atr_data(atr, data):
    return (enums['Atrs'].index(atr)<<24) + (data & 0xFFFFFF)

def decode_atr_data(num):
    return (enums['Atrs'][num>>24],num&0xFFFFFF)

def add_enum(key, value):
    value_original = value
    if value=="": value="None"
    value = capitalize(upper_snake_to_camel(value))
    if value in rename_enums: value = rename_enums[value]
    if key in enums:
        if not value in enums[key]: 
            enums[key].append(value)
            enum_to_original_string[value]=value_original
    else:
        enums[key]=[value]
        enum_to_original_string[value]=value_original
    return (key,value)

def write_file(path, content):
    generated_files_header = "//! This file is autogenerated by rs_generator.py.<br>Code in this file uses wynncraft item data from [wynnbuilder's github repo](https://raw.githubusercontent.com/hppeng-wynn/hppeng-wynn.github.io/dev/data/2.0.4.3/items.json)\n"
    if not os.path.exists(path.rsplit('\\',1)[0]):
        print(f"\n\033[1;31mFile Path Error:\033[0;0m: {path} does not exist.\n")
        os.mkdir(path.rsplit('\\',1)[0])
    f = open(path, 'w', encoding='utf-8')                        
    try:
        f.write(generated_files_header+content)
    except Exception as e:
        print(f"\n\033[1;31m{str(type(e))}:\033[0;0m: {str(e)}\n")
    f.close()

def generate_enum(data,key,enum_name=None,ignore=[]):
    # print("Generating from",key)
    if not type(data)==dict:
        if type(data)==list:
            for i in range(len(data)):
                generate_enum(data[i],key,enum_name,ignore)
        return
    searching = key
    next_key = key
    at_root=True
    if '.' in key:
        split = key.split('.',1) if not key[0]=='*' else key.split('.',2)[1::]
        searching = split[0]
        if len(split)>1:
            at_root=False
            next_key = split[1]
    if searching=='':
        for k in data.keys():
            if not k in ignore: 
                tempk,tempv=add_enum(enum_name, k)
                # adds to key_enums_types
                if not tempk in key_enums_types:
                    key_enums_types[tempk]={}
                key_enums_types[tempk][tempv]=type(data[k])
    elif searching=='*':
        for k in data:
            generate_enum(data[k],next_key,enum_name,ignore)
    elif searching in data.keys():
        if at_root:
            if type(data[searching])==list and type(data[searching][0])==str:
                for s in data[searching]: 
                    if not s in ignore: add_enum(key if enum_name==None else enum_name, s)
            else:
                if not data[searching] in ignore: add_enum(key if enum_name==None else enum_name, data[searching])
        else: generate_enum(data[searching],next_key,enum_name,ignore)
    elif key[0]=='*':
        for k in data:
            generate_enum(data[k],key,enum_name,ignore)

def make_enum_string(enum_name, use_original_name_for_tostring = False):
    global num_enum_strings_made
    if not type(enums[enum_name][0])==str:
        print("Wrong type for making enum string:",enum_name,"with type",str(type(enum_name)))
    formatted_name = capitalize(upper_snake_to_camel(enum_name))
    formatted_values = [capitalize(upper_snake_to_camel(e.replace('\'',''))) for e in enums[enum_name]]
    adder = f"#[derive(Clone,Default,PartialEq,PartialOrd,Eq,Ord,Copy,Debug)]\npub enum "+formatted_name+"{#[default]"
    # generate enums
    adder += ",".join(formatted_values)+"}\n"
    # generates an iterator for the enums
    # adder += "impl "+formatted_name+"{pub const NUM_VARIENTS:usize="+str(len(formatted_values))+";"
    # adder += f"pub const VARIENTS:[Self;Self::NUM_VARIENTS]=[{','.join([f"Self::{fv}" for fv in formatted_values])}];"
    # adder+="pub fn iter() -> std::array::IntoIter<Self,"+str(len(formatted_values))+">{Self::VARIENTS.into_iter()}}\n"
    
    adder+=f"impl WynnEnum for {formatted_name}{{const VARIENTS:&'static[Self]=&[{','.join([f"Self::{fv}" for fv in formatted_values])}];const ENUM_TYPE_ID:u8={num_enum_strings_made};}}"
    num_enum_strings_made+=1
    # generates a tryfrom u8 for the enum
    if len(formatted_values)<256:
        base_enum_type = "u8"
    else:
        base_enum_type = "u16"
    adder += f"impl std::convert::TryFrom<{base_enum_type}> for "+formatted_name+f"{{type Error=TryIntoWynnEnumError<{base_enum_type},Self>;fn try_from(n: {base_enum_type}) -> Result<Self,Self::Error> {{match n{{"
    for i in range(len(formatted_values)):
        adder+=f"""{i} => Ok({formatted_name}::{formatted_values[i]}), """
    adder+="""_ => Err(TryIntoWynnEnumError{from: n, to: Self::default()})}}}\n"""

    # generates a display for the enum
    adder += "impl fmt::Display for "+formatted_name+"""{fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {write!(f,"{}",match self{"""
    for i in range(len(formatted_values)):
        adder+=f"""{formatted_name}::{formatted_values[i]} => "{enum_to_original_string[enums[enum_name][i]] if use_original_name_for_tostring and enums[enum_name][i] in enum_to_original_string else enums[enum_name][i]}", """ #String::from(
    adder+="})}}"
    # adder+=f"\nimpl WynnEnum for "+formatted_name+"{const VARIENTS:&'static[Self]=}"
    adder+=f"enum_from_into!("+formatted_name+f", {base_enum_type},u32,u64,i32,i64,usize);"
    return adder


def setup_general_enums():
    enums["class"] = ["Archer","Warrior","Mage","Assassin","Shaman"]
    enums["skill"] = ["Str","Dex","Int","Def","Agi"]
    enums["DamType"] = ["Neutral","Earth","Thunder","Water","Fire","Air","Rainbow"]
    global general_enums
    general_enums = ['class','DamType','skill']
    skill_impl = "\nimpl super::TryIntoI12x5Idx for Skill{type Error = String;fn try_into(self) -> Result<super::I12x5Idx, Self::Error> {Ok(match self{Self::Str => super::I12x5Idx::_0,Self::Dex => super::I12x5Idx::_1,Self::Int => super::I12x5Idx::_2,Self::Def => super::I12x5Idx::_3,Self::Agi => super::I12x5Idx::_4})}}"
    write_file('src\\wynn_data\\general\\enums.rs',enums_files_imports+'\n'.join([make_enum_string(s) for s in general_enums])+skill_impl)

def setup_item_enums(data):
    enums["tier"]=["Common","Unique","Rare","Legendary","Set","Fabled","Mythic"]
    # enums["atkSpd"]=["SUPER_SLOW","VERY_SLOW","SLOW","NORMAL","FAST","VERY_FAST","SUPER_FAST"]
    enums["atkSpd"]=["SuperSlow","VerySlow","Slow","Normal","Fast","VeryFast","SuperFast"]
    enums["type"]=["Helmet","Chestplate","Leggings","Boots","Ring","Bracelet","Necklace","Bow","Spear","Wand","Dagger","Relik"]
    generate_enum(data,'items.category','category')
    generate_enum(data,'items.restrict','restrict')
    generate_enum(data,'items.majorIds','majorIds')

    # all of the following is for generating the Atrs enum
    atrs_ignore = ["drop", "dropInfo", "armorColor", "skin", "material", "armorType","lore", "quest", "set", "displayName","name"]
    item_props = ['type','tier','lvl','category','id','fixID','atkSpd','slots','restrict','majorIds','allowCraftsman','classReq','set']
    # bad at naming things, these are elemental item stats that aren't identified (?). 
    # except reqs are properties, not stats (by my made up naming convention). idk.
    # todo: ele defs should be included here. 
    special_data = ["strReq","dexReq","intReq","defReq","agiReq","str","dex","int","def","agi","nDam","eDam","tDam","wDam","fDam","aDam"]
    stats = ['hp','eDef','tDef','wDef','fDef','aDef','damMult','defMult']
    ids = ['damRaw']
    ele_ids = []
    temp = unique_keys(data['items'],atrs_ignore+item_props+special_data+stats)
    for atr in temp:
        snake = camel_to_snake(atr)
        if not atr in ids and not atr in ele_ids:
            if snake[1]=='_' and snake[0] in dmg_types and not atr.endswith('Steal'):
                s = "ele_"+snake[2::]+"s"
                ele_ids.extend([dmg_type+atr[1::] for dmg_type in (dmg_types[1::] if "def" in s else dmg_types)])
            else:
                ids.append(atr)
    for t in dmg_types[0:6]: ele_ids.append(f"{t}AddDam")
    enums['Atrs'] = item_props+special_data+stats+sorted(ids)+ele_ids

    global item_enums
    item_enums = ['type','tier','category','atkSpd','restrict','majorIds','Atrs']
    global ele_prop_atrs
    ele_prop_atrs = special_data
    global stat_atrs
    stat_atrs=stats+sorted(ids)+ele_ids
    atrs_docs = "/// Used to identify almost all types of data stored in wynncraft items. \n///\n/// The following item attributes are ignored due to them either taking up a lot of memory or just not being useful for my application:\n/// - `drop`\n/// - `dropInfo`\n/// - `armorColor`\n/// - `skin`\n/// - `material` \n/// - `armorType`\n/// - `lore`\n/// - `quest`\n/// # Naming Convention\n/// **Attributes** - (Almost) all data stored in wynncraft items<br>\n/// **Properties** - Data intrinsic to items that don't get counted when calculating a build's stats. ie: `Type`, `Tier`, `ClassReq`, etc...<br>\n/// **Stats** - All data used for calculating a build's stats, including all *identifications*, hp, and ele defs. Damages, skill reqs, and skill bonuses are not included. <br>\n/// **Identifications** - All item *attributes* which are determined when identifying an item. These stats vary based on `WynnItem.quality`, unless `Atrs::FixID` is true. "
    # consts=f"/// Total number of item attributes. Attributes include all stats and most of the other item properties (rarity, category, etc)\n///\n/// See enums::Atrs for more info\npub const NUM_ITEM_ATRS: usize = {len(enums['Atrs'])};\n"
    consts=f"/// Total number of item properties. Properties include most non-addable attributes of an item (rarity, category, etc)<br>See enums::Atrs for more info\npub const NUM_PROPS: usize = {len(item_props)};\n"
    consts+=f"/// Total number of item stats. Includes all standard identifications, in addition to things such as elemental defs<br>See enums::Atrs for more info\npub const NUM_STATS: usize = {len(stat_atrs)};\n"
    consts+=f"/// Total number of elemental stats.<br>See enums::Atrs for more info\npub const NUM_ELE_STATS: usize = {len(ele_ids)};\n"
    consts+=f"/// Simply `NUM_VARIENTS - NUM_STATS`<br>See `NUM_VARIENTS`, `NUM_STATS`, and `items::enums::Atrs` for more info\npub const NUM_NON_STATS: usize = {len(enums['Atrs'])-len(stat_atrs)};\n"
    consts+=f"/// Total number of identifications.<br>See `items::enums::Atrs` for more info\npub const NUM_IDS: usize = {len(ids)+len(ele_ids)};\n"
    consts+=f"/// `NUM_VARIENTS - NUM_IDS`<br>See `items::enums::Atrs` for more info\npub const NUM_NON_IDS: usize = {len(enums['Atrs'])-len(ids)-len(ele_ids)};\n"
    write_file('src\\wynn_data\\items\\enums.rs',enums_files_imports+'\n'.join([(f"{atrs_docs}\n" if n=='Atrs' else '')+make_enum_string(n) for n in item_enums])+f"impl Atrs{{{consts}}}")

def get_enum_with_value(value,ignore=[]):
    v2 = capitalize(upper_snake_to_camel(value))
    res = []
    for e in enums:
        if not e in ignore and (value in enums[e] or v2 in enums[e]): res.append(e)
    return res

def parse_data(value, *, key = None, ret_len_if_list = False, ignore_enums = []):
    key_formatted = upper_snake_to_camel(key)
    if key in rename_enums or key_formatted in rename_enums:
        key=rename_enums[key if key in rename_enums else key_formatted]
    if type(value)==int:
        return value
    elif type(value)==float:
        return int(value*100) # scuffed
    elif type(value)==tuple and len(value)==2 and type(value[0])==int and type(value[1])==int:
        return ((value[0]&0xFFF)<<12) | (value[1]&0xFFF)
    elif type(value)==str:
        if value.split("-",1)[0].isnumeric():
            temp = value.split("-",1)
            return ((int(temp[0])&0xFFF)<<12) | (int(temp[1])&0xFFF)
        value = capitalize(upper_snake_to_camel(value)) if not value=="" else 'None'
        if value in rename_enums: value = rename_enums[value]
        if not key==None and value in enums[key]:
            return enums[key].index(value)
        else:
            for k in enums:
                if k in ignore_enums: continue
                for i in range(len(enums[k])):
                    if enums[k][i].upper()==value.upper():
                        # print("found",value,"at index",i,"in",k)
                        return i
            print("Error parsing data",value,"with key",key)
    elif type(value)==list:
        if len(value)==0:
            return 0
        if ret_len_if_list:
            return len(value)
        elif len(value)==1 and not key==None:
            if value[0] in enums[key]:
                return enums[key].index(value[0])
    elif type(value)==dict and ret_len_if_list:
        return len(value)
    elif type(value)==bool:
        return 0 if value==False else 1
    else:
        print("Failed to parse",value,"with type",str(type(value)))
    return 0

def setup_set_enums(data):
    enums['sets']=["None"]
    enums['sets'].extend([st for st in data['sets']])
    global set_enums
    set_enums = ['sets']
    global get_set
    for st in data['sets']: 
        for item in data['sets'][st]['items']: get_set[item] = st
    write_file('src\\wynn_data\\sets\\enums.rs',enums_files_imports+make_enum_string('sets'))
    
def setup_set_data(data):
    limit=10000
    set_bonuses = ["&[]"]
    # get_set={}
    for st in data['sets']:
        bonuses = []
        # for itm in data['sets'][st]['items']:
        #     get_set[itm]=upper_snake_to_camel(st)
        for b in data['sets'][st]['bonuses']:
            b_ids = {}
            for key, value in b.items():
                real_key = 'fixID' if key=='illegal' else 'spd' if key=='ws' else key
                b_ids[real_key]=parse_atr_data(real_key,parse_data(value,key=real_key))
            bonuses.append("("+str(compress_skills(get_skills(b)))+", &["+','.join([str(b_ids[i]) for i in enums['Atrs'] if i in b_ids])+"])")
        set_bonuses.append("&["+','.join(bonuses)+"]")
        limit-=1
        if limit<=0: break
    gen_set_bonuses_const = "pub const SET_BONUSES: &'static[&'static [(i64,&'static [u32])]] = &["+',\n'.join(set_bonuses)+"];"
    write_file('src\\wynn_data\\sets\\set_bonus_data.rs',gen_set_bonuses_const)
    
def setup_item_data(data):
    counter = 0
    wynn_items=[]
    all_item_names=[]
    for d in data['items']:
        struct_data = {}
        partitions = [0,0,0,0]
        for k, v in d.items():            
            if not k in enums['Atrs'] or k=='set' or v=='0-0': continue
            if k=='tier' and (v=='Set' or d['name'] in get_set): # weird wonkyness because GM's boots? wtf is this item even?
                if d['name'] in get_set or d['displayName'] in get_set: struct_data['set']=parse_atr_data('set',enums['sets'].index(get_set[d['name' if d['name'] in get_set else 'displayName']]))
                # (enums['Atrs'].index('set')<<24)+enum_builder['sets'][1].index(get_set[d['name' if d['name'] in get_set else 'displayName']])
            struct_data[k] = parse_atr_data(k,parse_data(v,key=k))
        idx = 0
        num_props = 0
        partition_counter = [0,0,0]
        for x in enums['Atrs']:
            if x in struct_data:
                if x in ele_prop_atrs:
                    if num_props==0: num_props=idx
                    if x in ele_prop_atrs[0:5]: partition_counter[0]+=1
                    elif x in ele_prop_atrs[5:10]: partition_counter[1]+=1
                    elif x in ele_prop_atrs[10:16]: partition_counter[2]+=1
                elif x in stat_atrs: break
                idx+=1
        if num_props==0: num_props=idx
        partitions[0]=num_props
        for i in range(len(partition_counter)):
            partitions[i+1]=partitions[i]+partition_counter[i]
        wynn_items.append('&super::WynnItemData{name: "'+d['displayName']+f'", sps_req_data: {compress_skills(get_skills(d, "Req", -1024))}, sps_bonus_data: {compress_skills(get_skills(d))}, partitions: ({",".join([str(n) for n in partitions])}), data: &['+','.join([str(struct_data[x]) for x in enums['Atrs'] if x in struct_data])+"]}")
        
        parsed_const_name = ''.join([c if c.isalnum() or c==' ' else ' ' if c=='-' else '' for c in d['displayName']])
        is_duplicate = False
        for _,name in all_item_names:
            if parsed_const_name.upper()==name.upper(): 
                is_duplicate=True
                break
        if not is_duplicate:
            all_item_names.append((counter,parsed_const_name))
        
        counter += 1
        if counter>=10000: break

    gen_items_const = """pub const ALL_ITEMS: &'static[&'static super::WynnItemData] = &[&super::WynnItemData{name: "Invalid Item", sps_req_data: 0, sps_bonus_data: 0, partitions: (0,0,0,0), data:&[]},"""+',\n'.join(wynn_items)+"];"
    
    item_from_name_matcher = f"#![allow(unused)]\nimpl super::WynnItem{{{''.join([f'pub const {all_item_names[i][1].upper().replace(' ','_')}: Self = Self::from_idx({all_item_names[i][0]+1});{'\n' if i%20==0 else ''}' for i in range(len(all_item_names))])}}}"
    item_from_name_matcher += f"\nuse super::WynnItem;\n#[macro_export]\nmacro_rules! item_from_tt({''.join([f'({all_item_names[i][1]}) => {{WynnItem::{all_item_names[i][1].upper().replace(' ','_')}}};{'\n' if i%50==0 else ''}' for i in range(len(all_item_names))])});"

    write_file('src\\wynn_data\\items\\items_list.rs',gen_items_const)
    write_file('src\\wynn_data\\items\\item_consts.rs',item_from_name_matcher)
    
def unique_keys(data,ignore=[]):
    res = []
    if type(data)==dict:
        for key in data.keys():
            if not key in res and not key in ignore:
                res.append(key)
    elif type(data)==list and type(data[0])==dict:
        for d in data:
            for key in d.keys():
                if not key in res and not key in ignore:
                    res.append(key)
    else:
        print("unique_keys() called on non-dict or list type")
    return res

def sort_keyenums_by_type(keyenum, ordered_types):
    if not keyenum in key_enums_types:
        print("Keyenum",keyenum,"not found in key_enums_types")
        return
    res = {t : [] for t in ordered_types}
    if not 'any' in res:
        res['any']=[]
    for k,itm in key_enums_types[keyenum].items():
        if not itm in res:
            res['any'].append(k)
        else:
            res[itm].append(k)
    curr=0
    for t in ordered_types:
        for i in range(len(res[t])):
            enums[keyenum][curr]=res[t][i]
            curr+=1


class AtreeItem:
    def __init__(self, data):
        self.name=data['display_name']
        self.effects=[]
        if 'effects' in data:
            for effect in data['effects']:
                effect_data = []
                if 'type' in effect:
                    effect_data.append(enums['EffectType'].index(effect['type']))
                if 'cost' in effect and 'base_spell' in effect:
                    effect_data.append(parse_atr_data(f"spRaw{effect['base_spell']}",effect['cost']))
                self.effects.append(effect_data)

def setup_atree(data,for_wynn_class=None):
    if for_wynn_class==None:
        generate_enum(data,"*.*.","AtreeKey",['req_archetype','desc','display','__TODO'])
        print("AtreeKeys",enums['AtreeKey'])

        enums['Archetype']=['None']
        generate_enum(data,"*.archetype","Archetype")
        print("Archetypes:",enums['Archetype'])

        generate_enum(data,"*.effects.","EffectKey",['display','spell_type'])
        sort_keyenums_by_type('EffectKey',['any',list,tuple,dict])
        print("EffectKeys:",enums['EffectKey'])
    
        generate_enum(data,"*.effects.type","EffectType")
        print("EffectTypes:",enums['EffectType'])

        generate_enum(data,"*.effects.bonuses.type","BonusType")
        print("BonusTypes:",enums['BonusType'])

        generate_enum(data,"*.effects.parts.","EffectPartKey",['display'])
        sort_keyenums_by_type('EffectPartKey',['any',list,tuple,dict])
        print("EffectPartKeys:",enums['EffectPartKey'])

        generate_enum(data,"*.effects.parts.type","EffectPartType")
        print("EffectPartTypes:",enums['EffectPartType'])

        general_atree_enums = ['AtreeKey','Archetype','EffectKey','EffectType','BonusType','EffectPartKey','EffectPartType']

        write_file(f'src\\wynn_data\\atree\\enums.rs',enums_files_imports+'\n'.join([make_enum_string(n) for n in general_atree_enums]))

        for wynn_class in data:
            setup_atree(data[wynn_class],for_wynn_class=wynn_class)
        return

    enums['AtreeItems']=[]
    generate_enum(data,"*.display_name","AtreeItems")
    print("AtreeItems:",enums['AtreeItems'])

    enums['Prop']=[]
    generate_enum(data,"*.properties.","Prop")
    print("Props",enums['Prop'])

    enums['Spell']=['Melee']
    generate_enum(data,"*.effects.name","Spell")
    print("Spells:",enums['Spell'])

    enums['SpellPart']=["None","Total","Dps","TotalDps"]
    generate_enum(data,"*.effects.parts.name","SpellPart")
    generate_enum(data,"*.effects.target_part","SpellPart")
    print("SpellParts:",enums['SpellPart'],len(enums['SpellPart']))

    global atree_enums
    atree_enums = ['AtreeItems','AtreeKey','Archetype','Prop','EffectKey','Spell','EffectType','BonusType','SpellPart','EffectPartKey','EffectPartType']
    class_specific_atree_enums = ['AtreeItems','Prop','Spell','SpellPart']
    write_file(f'src\\wynn_data\\atree\\{for_wynn_class.lower()}\\mod.rs','pub (super) mod atree_data;'+enums_files_imports+'\n'.join([make_enum_string(n, n=="AtreeItems") for n in class_specific_atree_enums]))

    parsed_data = []
    for atree_item in data:
        if not 'properties' in atree_item:
            print(atree_item['display_name'],"does not have key 'properties' ??")
            atree_item['properties']=[]
        parents = setup_file_from_data(atree_item['parents'],False)
        deps = setup_file_from_data(atree_item['dependencies'],False)
        blockers = setup_file_from_data(atree_item['blockers'],False)
        props = setup_file_from_data(atree_item['properties'],False)
        effects = []
        for e in atree_item['effects']:
            temp=setup_file_from_data(e,False,[['AtreeKey','AtreeItems','EffectPartType'],['AtreeKey','EffectType','Spell','EffectKey','AtreeItems'],['AtreeKey','EffectType','Spell','EffectKey','AtreeItems']],['behavior'],{'target_part' : "SpellPart"})
            effects.append(f"&[{','.join([str(n) for n in temp])}]")
        data = setup_file_from_data(atree_item,False,[],['parents','dependencies','blockers','properties','effects','desc','req_archetype','display','__TODO'])
        appender = "&AtreeItemData{name:\""+atree_item['display_name']
        appender+='",parents:&['+','.join([str(n) for n in parents])
        appender+='],deps:&['+','.join([str(n) for n in deps])
        appender+='],blockers:&['+','.join([str(n) for n in blockers])
        appender+='],props:&['+','.join([str(n) for n in props])
        appender+='],effects:&['+','.join([str(n) for n in effects])
        appender+='],data:&['+','.join([str(n) for n in data])
        appender+=f'],enum_id:AtreeItems::{capitalize(upper_snake_to_camel(atree_item['display_name']))}}}'
        parsed_data.append(appender)
    gen_atree_data = f"pub const ATREE_DATA: &'static[&'static AtreeItemData<{for_wynn_class}AtreeEnums>] = &["+',\n'.join(parsed_data)+"];"
    write_file(f'src\\wynn_data\\atree\\{for_wynn_class.lower()}\\atree_data.rs',f'use super::{{AtreeItems,super::{{AtreeItemData,{for_wynn_class}AtreeEnums}}}};\n'+gen_atree_data)


def setup_file_from_data(data,ignore_empty=False,ignore_enums=[],ignore_keys=[],use_enum_for_data_key={}):
    res=[]
    ignore = ignore_enums
    recursive_ignores = False
    if type(ignore_enums)==list and len(ignore_enums)>0 and type(ignore_enums[0])==list:
        ignore = ignore_enums[0]
        recursive_ignores=True
    if type(data)==list:
        for d in data:
            if type(d)==dict:
                res.extend(setup_file_from_data(d,ignore_empty,ignore_enums[1::] if recursive_ignores else ignore_enums))
            else:
                temp = parse_data(d,ignore_enums=ignore)
                res.append(temp if temp >= 0 else temp & 0xFFFFFFFF)
        return res
    unsorted_res = {}
    for key,value in data.items():
        if ignore_empty and (type(value)==dict or type(value)==list) and len(value)==0:
            continue
        if key in ignore_keys:
            continue
        temp = get_enum_with_value(key,ignore)
        if len(temp)==0:
            continue
        while len(temp)>1 and parse_data(key,ignore_enums=ignore,key=temp[0]) in unsorted_res.keys(): # safety check for overriding keys (assume we don't want to override)
            temp.pop(0)
        # print("Parsing",key,value,"as",parse_data(key,ignore_enums=ignore,key=temp[0]),parse_data(value,ignore_enums=ignore,ret_len_if_list=True))
        parsed = (parse_data(key,ignore_enums=ignore,key=temp[0])<<24) + (parse_data(value,ignore_enums=ignore,key=use_enum_for_data_key[key] if key in use_enum_for_data_key else None,ret_len_if_list=True) & 0xFFFFFF)
        
        # res.append(parsed)
        unsorted_res[parsed >> 24] = [parsed]        
        if (type(value)==list or type(value)==dict) and len(value)>0:
            temp = setup_file_from_data(value,ignore_empty,ignore_enums[1::] if recursive_ignores else ignore_enums)
            unsorted_res[parsed >> 24] = [(parsed>>24<<24)+len(temp)]
            unsorted_res[parsed >> 24].extend(temp)
    for key in sorted(unsorted_res):
        res.extend(unsorted_res[key])
    return res

def reparse_atree_data(data):
    for clas in data:
        for abil in data[clas]:
            if 'effects' in abil:
                for effect in abil['effects']:
                    if effect['type']=='raw_stat' and 'bonuses' in effect:
                        i=0
                        while i < len(effect['bonuses']):
                            bonus = effect['bonuses'][i]
                            if bonus['name'].endswith('DamAddMin'):
                                found_add = False
                                for j in range(i):
                                    if effect['bonuses'][j]['name'].endswith('AddDam'):
                                        effect['bonuses'][j]['value']+=bonus['value']<<12
                                        found_add = True
                                        del effect['bonuses'][i]
                                        break
                                if not found_add:
                                    bonus['name']=bonus['name'][0]+'AddDam'
                                    bonus['value']=bonus['value']<<12
                                    i+=1
                            elif bonus['name'].endswith('DamAddMax'):
                                found_add = False
                                for j in range(i):
                                    if effect['bonuses'][j]['name'].endswith('AddDam'):
                                        effect['bonuses'][j]['value']+=bonus['value']
                                        found_add = True
                                        del effect['bonuses'][i]
                                        break
                                if not found_add:
                                    bonus['name']=bonus['name'][0]+'AddDam'
                                    bonus['value']=bonus['value']
                                    i+=1
                            else:
                                i+=1
                        i=0
                        while i < len(effect['bonuses']):
                            bonus = effect['bonuses'][i]
                            abil = bonus['abil'] if 'abil' in bonus else bonus['name'].split('.')[-1] if bonus['name'].startswith('damMult') else ''
                            effect['bonuses'][i] = {bonus['type'] : abil, bonus['name'] if not '.' in bonus['name'] else bonus['name'].split('.')[0] : bonus['value']}
                            i+=1
    # print(atree_items["Archer"])

if __name__=='__main__':
    # f = open('items.json', 'r', encoding='utf-8')
    f = urllib.request.urlopen("https://raw.githubusercontent.com/hppeng-wynn/hppeng-wynn.github.io/dev/data/2.0.4.3/items.json")
    try:
        data = json.load(f)
    except Exception as e:
        print(f"\n\033[1;31mError loading file: \033[93m{str(type(e))}:\033[0;0m {str(e)}\n")
    f.close()
    print("['"+"','".join("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz+-")+"']")
    print(len("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz+-"))

    # construct_items_rust(data, False)
    

    setup_general_enums()
    setup_item_enums(data)
    setup_set_enums(data)

    setup_item_data(data)
    setup_set_data(data)
    
    f = urllib.request.urlopen("https://raw.githubusercontent.com/wynnbuilder/wynnbuilder.github.io/master/data/2.0.4.3/atree.json")
    try:
        data = json.load(f)
    except Exception as e:
        print(f"\n\033[1;31mError loading file: \033[93m{str(type(e))}:\033[0;0m {str(e)}\n")
    f.close()

    reparse_atree_data(data)
    setup_atree(data)

    tster = []
    replace_spell_data = []
    tster2 = []
    for cls in data:
        for atreeitm in data[cls]:
            for eff in atreeitm['effects']:
                for k in eff:
                    if not k in tster2 and (type(eff[k])==list or type(eff[k])==tuple or type(eff[k])==dict):
                        tster2.append(k)
                counter = 0
                # if eff['type']=='raw_stat' and 'bonuses' in eff:
                #     print(eff['bonuses'])
                if eff['type']=='replace_spell':
                    for k in eff:
                        if len(replace_spell_data)<=counter:
                            replace_spell_data.append([])
                        if not k in replace_spell_data[counter]:
                            replace_spell_data[counter].append(k)
                        counter+=1
                if not eff['type']=='add_spell_prop': continue
                counter = 0
                for k in eff:
                    if len(tster)<=counter:
                        tster.append([])
                    if not k in tster[counter]:
                        tster[counter].append(k)
                    if k=='name': print(eff['name'])
                    counter+=1
    print("add_spell_props",tster)
    print("iterable effect keys:",tster2)
    print("replace_spells",replace_spell_data)

    # generate_enum(data,'*.effects.name','AtreeSpells')
    # print("#####")
    # print(make_enum_string('AtreeSpells'))
    # write_file("src\\wynn_data\\atree\\enums.rs",enums_files_imports+make_enum_string('AtreeSpells'))
    # print([upper_snake_to_camel(e) for e in enums['AtreeSpells']])


# quoted from salted 
# Spell Damage Conversion now applies to ALL of your damage types. In 1.20 and earlier, it used to only apply to Neutral Damage. So for example, if your weapon deals 50 Water Damage and you cast a spell that has 100% Neutral and 50% Fire damage, you will end up dealing 50 Water Damage + 25 Fire Damage
# Spell Damage Conversion is also not a conversion anymore, but simply adds damage directly. Previously, 20% Water Conversion on a spell meant it would take away 20% of your damage and transform it into Water. In 2.0, it simply adds 20% more Water Damage. This change is to make spell damage easier to understand.
# There is now a third damage bonus type, only found in Ability Trees called Additive Damage. It is added as pure damage not affected by your spell attack speed modifier before item bonuses kick in. Contrary to Raw, it is not modified by your spell damage multiplier. This means that fast attack abilities are more affected by it.
# Raw Damage is now added proportionally to ALL of your damage types. Previously, it used to add the damage as flat Neutral Damage. In 2.0, it will be spread to all neutral + elemental damage you deal. So for example, if you deal 50 Neutral Damage and 100 Water Damage, and have +60 Raw Damage, you will end up dealing 70 Neutral and 140 Water Damage.
# We've added new elemental-only Raw Damage as well. They aren't used on any item yet, but they may in the future. These raw damages only get added if you deal that particular elemental damage as your base damage. So for example, if you deal 50 Fire Damage and have +10 Water Raw Damage, nothing will happen. But if you cast a water spell, the +10 Damage will get applied.

# These last two changes were how raw damage was meant to work since Gavel, but the system wasn't flexible enough to allow it. Now, both % and raw damage work in a similar manner. While playing normally, you may feel like mobs' elemental defences and weaknesses matter more than they used to.
    
# print(get_items_with_data("eSdPct"))
# print(get_items_with_data("majorIds"))
    
# construct_items_rust()

# https://forums.wynncraft.com/threads/2-0-spellbound-changelog.299715/

#Agility will not fully nullify damage when triggered anymore. Instead, it will deal 10% of the damage to you and deal no knockback. Its scaling is slightly higher than defence, but they are both effectively equal.


@DeprecationWarning
def construct_items_rust(data, update=False):
    # stats to ignore during search. some of these stats are re-added later to maintain some ordering scheme or for type modifications
    ignore =["drop", "dropInfo", "armorColor", "skin", "material", "armorType","lore", "quest", "set", "displayName","name"]
    # used when coverting to snake case - the keyword 'type' and 'ref' don't work in rust, so change these
    special_renames = {"fixID" : "fix_id", "eSteal" : "em_steal", "ref" : "reflect", "type" : "item_type"}
    # addable ids (ie, spell percent gets added, but level req, or skill reqs dont get added)
    addable_ids = ["str","dex","int","def","agi", "hp","jh","weakenEnemy","kb","mr","expd","hpBonus","spd","ms","ref","atkTier","eSteal","poison","thorns","sprintReg","ls","xpb","lb","sprint","slowEnemy"]
    # dict of keyname : (capitalized camel case format, snake case format, data type)
    stats = {}
    # item properties list, with a few properties already set in a specific order. other item properties just get added on to this list. 
    item_props = ["name","type","tier","lvl","category","id","fixID","atkSpd"]
    # all item ids, with a few ids already set in a specific order. other item ids get added on to this list. -- NAMING CONVENTION DIFFERENT IN RUST, THESE ARE ALL STATS NOT IDS
    ids = ['hp','eDef','tDef','wDef','fDef','aDef']
    # i'm too lazy to change the naming convention for this file, so this is used to find the true number of stats and ids (for rust naming convention)
    num_stats_not_ids = len(ids)
    # this is used to split up ids into elemental and non-elemental ids
    ele_ids = []
    non_ele_ids = []
    skill_bonuses = ["str","dex","int","def","agi"]
    # idk what this does tbh
    ele_stats = []
    # i've arbitrarily determined that the best way to set up WynnItems (struct) is to store all data in a single array, 
    # then define partition indicies to separate properties, ability point stuff, damages, then ids in this array. 
    save_separately = ["strReq","dexReq","intReq","defReq","agiReq","str","dex","int","def","agi","nDam","eDam","tDam","wDam","fDam","aDam"]
    # generates enums for the listed keys
    enum_builder = {"majorIds": ([],[]), "type": ([],[]), "restrict": ([],[]), "category": ([],[]), "tier": ([],[]), "atkSpd": ([],[]), "classReq": ([],[]), "sets": ([],[])}
    enum_names = [s[0].upper()+s[1::] for s in enum_builder.keys()]
    for d in data['items']:
        for k in d.keys():
            if not k in stats and not k in ignore:
                t = "i32"
                addable = False
                if not type(d[k])==int:
                    if type(d[k])==str:
                        if d[k].split("-",1)[0].isnumeric():
                            t="u16,u16"
                            addable=True
                        elif k in enum_builder:
                            t=capitalize(k)
                        else:
                            t="String"
                    elif type(d[k])==list:
                        t="MajorIds" # please no items with multiple major ids or else everything breaks
                    else:
                        t=type(d[k]).__name__ # only time this gets called is for bools
                else:
                    if k in addable_ids or k.lower().endswith("raw") or k.lower().endswith("pct") or k.lower().endswith("regen") or k.lower().endswith("def") or k[-1].isnumeric():
                        addable=True
                # order.insert(0 if addable else -1,k)
                snake = special_renames[k] if k in special_renames.keys() else camel_to_snake(k)
                if addable:
                    if k in save_separately or k in ids:
                        # do nothing? 
                        useless = 0
                    elif snake[1]=='_' and snake[0] in dmg_types:
                        s = "ele_"+snake[2::]+"s"
                        if not s in ele_stats: 
                            ele_stats.append(s)
                            ele_ids.extend([dmg_type+k[1::] for dmg_type in (dmg_types[1::] if "def" in s else dmg_types)])
                    else:
                        non_ele_ids.append(k)
                else:
                    if not k in item_props and not k in save_separately:
                        item_props.append(k)
                stats[k]=(capitalize(k),snake, t)
            for k, v in enum_builder.items():
                if k in d:
                    if type(d[k])==list:
                        for val in d[k]:
                            if len(val)>0 and not val.lower() in [lst_val.lower() for lst_val in v[0]]:
                                v[0].append(capitalize(val))
                                v[1].append(upper_snake_to_camel(val))
                    else:
                        if len(d[k])>0 and not d[k].lower() in [lst_val.lower() for lst_val in v[0]]:
                            v[0].append(capitalize(d[k]))
                            v[1].append(upper_snake_to_camel(d[k]))
                            
    for t in dmg_types[0:6]: ele_ids.append(f"{t}DamAddMin")
    for t in dmg_types[0:6]: ele_ids.append(f"{t}DamAddMax")

    for e in ele_ids:
        if not e in stats:
            stats[e]=(capitalize(e),camel_to_snake(e), "i32")
    item_props.pop(0)
    item_props.append("set")
    ids.extend(non_ele_ids+ele_ids)
    order = item_props +save_separately+ ids

    global atrs
    atrs = order

    # overriding the order for specific enums (these make more logical sense)
    enum_builder["tier"]=["Common","Unique","Rare","Legendary","Set","Fabled","Mythic"]
    enum_builder["atkSpd"]=(["SUPER_SLOW","VERY_SLOW","SLOW","NORMAL","FAST","VERY_FAST","SUPER_FAST"],["SuperSlow","VerySlow","Slow","Normal","Fast","VeryFast","SuperFast"])
    enum_builder["type"]=["Helmet","Chestplate","Leggings","Boots","Ring","Bracelet","Necklace","Bow","Spear","Wand","Dagger","Relik"]
    # need an enum for all the ids as well
    stats['set']=("Set","set","Sets")
    enum_builder["Skill"] = [capitalize(sk) for sk in skill_bonuses]
    enum_builder["DamType"] = ["Neutral","Earth","Thunder","Water","Fire","Air","Rainbow"]
    enum_builder["Atrs"] = ([k for k in order],[f"{stats[k][0]}" for k in order])

    set_bonuses = ["&[]"]
    # get set from item name
    get_set = {}
    enum_builder['sets'][0].append("None")
    enum_builder['sets'][1].append("None")

    for k, v in enum_builder.items():
        enum_name = capitalize(k)
        if type(v[0])==list: 
            enums[enum_name]=v[0]
        else:
            enums[enum_name]=v

    # set this to large number to parse all sets. 
    limit = 10000
    for st in data['sets']:
        enum_builder['sets'][0].append(capitalize(st))
        enum_builder['sets'][1].append(upper_snake_to_camel(st))
        bonuses = []
        for itm in data['sets'][st]['items']:
            get_set[itm]=upper_snake_to_camel(st)
        for b in data['sets'][st]['bonuses']:
            b_ids = {}
            for key, value in b.items():
                real_key = 'fixID' if key=='illegal' else 'spd' if key=='ws' else key
                stat = stats[real_key]
                # print(value)
                # print(order.index(real_key)<<24 + (value & 0xFFFFFF))
                b_ids[real_key] = (order.index(real_key)<<24) + ((value if stat[2]=="i32" or stat[2]=="u32" else 1 if stat[2]=="bool" else 0)&0xFFFFFF)
            bonuses.append("("+str(compress_skills(get_skills(b)))+", &["+','.join([str(b_ids[i]) for i in order if i in b_ids])+"])")
        set_bonuses.append("&["+','.join(bonuses)+"]")
        limit-=1
        if limit<=0: break

    # generates the enum declarations (also a tostring method for each enum)
    enums_string = []
    for k, v in enum_builder.items():
        enum_name = capitalize(k)
        if not type(v[0])==list: 
            enum_builder[k]=(v,v)
            v=enum_builder[k]
        adder = f"#[derive(Clone{',Default' if len(v)<=2 else ''},PartialEq,PartialOrd,Eq,Ord,Copy,Debug)]\npub enum "+ enum_name+f"{'{#[default]' if len(v)<=2 else '{'}"
        if len(v)>2: adder += ",".join([v[1][i]+'('+v[2][i]+')' for i in range(len(v[1]))])+"}\n"
        else: adder += ",".join(v[1])+"}\n"
        # adder += "impl "+enum_name+"{pub fn from_usize(n: usize) -> Result<Self,String> {match n{"
        # if len(v)>2:
        #     for i in range(len(v[0])):
        #         t = v[2][i].split(',')[0]
        #         adder+=f"""{i} => Result::Ok({enum_name}::{v[1][i]}({t+'::default(),'+t+'::default()' if ',' in v[2][i] else t+'::default()' if not 'Vec' in v[2][i] else 'Vec::default()'})), """
        # else:
        #     for i in range(len(v[0])):
        #         adder+=f"""{i} => Result::Ok({enum_name}::{v[1][i]}), """
        # adder+="""_ => Result::Err(String::from("Invalid number"))}}\npub fn from_u32(n: u32) -> Result<Self,String>{match n{"""
        # if len(v)>2:
        #     for i in range(len(v[0])):
        #         t = v[2][i].split(',')[0]
        #         adder+=f"""{i} => Result::Ok({enum_name}::{v[1][i]}({t+'::default(),'+t+'::default()' if ',' in v[2][i] else t+'::default()' if not 'Vec' in v[2][i] else 'Vec::default()'})), """
        # else:
        #     for i in range(len(v[0])):
        #         adder+=f"""{i} => Result::Ok({enum_name}::{v[1][i]}), """
        # adder+="""_ => Result::Err(String::from("Invalid number"))}}\npub fn to_num(&self) -> usize{match self{"""
        # if len(v)>2:
        #     for i in range(len(v[0])):
        #         adder+=f"""{enum_name}::{v[1][i]}({'_,_' if ',' in v[2][i] else '_'}) => {i}, """
        # else:
        #     for i in range(len(v[0])):
        #         adder+=f"""{enum_name}::{v[1][i]} => {i}, """
        # adder+="}}"
        adder += "impl "+enum_name+"{pub const NUM_VARIENTS:usize="+str(len(v[0]))+";pub fn iter() -> std::array::IntoIter<Self,"+str(len(v[0]))+">{["
        if len(v)>2:
            for i in range(len(v[0])):
                adder+=f"""{enum_name}::{v[1][i]}({'Default::default(),Default::default()' if ',' in v[2][i] else 'Default::default()'}),"""
        else:
            for i in range(len(v[0])):
                adder+=f"""{enum_name}::{v[1][i]},"""
        adder+="].into_iter()}"
        if len(v)>2:
            adder+="\npub fn varient_eq(&self, other: &Self) -> bool {discriminant(self) == discriminant(other)}"
        adder+="""}\n"""

        adder += "impl std::convert::TryFrom<u8> for "+enum_name+"{type Error=TryIntoWynnEnumError<u8,Self>;fn try_from(n: u8) -> Result<Self,Self::Error> {match n{"
        if len(v)>2:
            for i in range(len(v[0])):
                t = v[2][i].split(',')[0]
                adder+=f"""{i} => Ok({enum_name}::{v[1][i]}({t+'::default(),'+t+'::default()' if ',' in v[2][i] else t+'::default()' if not 'Vec' in v[2][i] else 'Vec::default()'})), """
        else:
            for i in range(len(v[0])):
                adder+=f"""{i} => Ok({enum_name}::{v[1][i]}), """
        adder+="""_ => Err(TryIntoWynnEnumError{from: n, to: Self::default()})}}}\n"""

        adder += "impl fmt::Display for "+enum_name+"""{fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {write!(f,"{}",match self{"""
        if len(v)>2:
            for i in range(len(v[0])):
                adder+=f"""{enum_name}::{v[1][i]}({'v1,v2' if ',' in v[2][i] else 'v'}) => format!("{v[0][i]}: {'{}, {}",v1,v2' if ',' in v[2][i] else '{}",v'}), """
        else:
            for i in range(len(v[0])):
                adder+=f"""{enum_name}::{v[1][i]} => "{v[0][i]}", """ #String::from(
        adder+="})}}"
        adder+="\nimpl WynnEnum for "+enum_name+"{}"
        adder+="enum_from_into!("+enum_name+", u8, u32,u64,i32,i64,usize);"
        enums_string.append(adder)
    enums_string.append("impl super::TryIntoI12x5Idx for Skill{type Error = String;fn try_into(self) -> Result<super::I12x5Idx, Self::Error> {Ok(match self{Self::Str => super::I12x5Idx::_0,Self::Dex => super::I12x5Idx::_1,Self::Int => super::I12x5Idx::_2,Self::Def => super::I12x5Idx::_3,Self::Agi => super::I12x5Idx::_4})}}")
    # consts = f"mod items_list; use core::fmt; use std::mem::discriminant; use std::vec::IntoIter; pub const NUM_ITEM_ATRS: usize = {len(order)}; pub const NUM_ITEM_PROPS: usize = {len(item_props)}; pub const NUM_ITEM_IDS: usize = {len(ids)}; pub const NUM_ELE_IDS: usize = {len(ele_ids)}; pub const NUM_NON_IDS: usize = {len(order)-len(ids)};const DIGITS: [char; 64] = ['0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z','a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z','+','-'];"
    # consts+="\nconst fn parse_data_atr(n: u32)->u32{n>>24}const fn parse_data_u32(n: u32)->u32{n&0xFFFFFF}const fn parse_data_i32(n: u32)->i32{(n as i32)<<8>>8}" #parse_data_i32(n: u32)->i32{((n&0x800000)*0x1FF|n&0xFFFFFF) as i32}

    consts=f"/// Total number of item attributes. Attributes include all stats and most of the other item properties (rarity, category, etc)\n///\n/// See enums::Atrs for more info\npub const NUM_ITEM_ATRS: usize = {len(order)};\n"
    consts+=f"/// Total number of item properties. Properties include most non-addable attributes of an item (rarity, category, etc)\n///\n/// See enums::Atrs for more info\npub const NUM_ITEM_PROPS: usize = {len(item_props)};\n"
    consts+=f"/// Total number of item stats. Includes all standard identifications, in addition to things such as elemental defs\n///\n/// See enums::Atrs for more info\npub const NUM_ITEM_STATS: usize = {len(ids)};\n"
    consts+=f"/// Total number of elemental stats.\n///\n/// See enums::Atrs for more info\npub const NUM_ELE_STATS: usize = {len(ele_ids)};\n"
    consts+=f"/// Simply `NUM_ITEM_ATRS - NUM_ITEM_STATS`\n///\n/// See `NUM_ITEM_ATRS`, 'NUM_ITEM_STATS`, and `enums::Atrs`` for more info\npub const NUM_NON_STATS: usize = {len(order)-len(ids)};\n"
    consts+=f"/// Total number of identifications.\n///\n/// See enums::Atrs for more info\npub const NUM_ITEM_IDS: usize = {len(ids)-num_stats_not_ids};\n"
    consts+=f"/// `NUM_ITEM_ATRS - NUM_ITEM_IDS`\n///\n/// See enums::Atrs for more info\npub const NUM_NON_IDS: usize = {len(order)-len(ids)+num_stats_not_ids};\n"

    wynn_item_struct = "struct WynnItemData<'a>{name: &'a str, sps_req_data: i64, sps_bonus_data: i64, partitions: (usize,usize,usize,usize), data: &'a [u32]}impl <'a>WynnItemData<'a>{fn data_atr(&self, idx: usize) -> u32{parse_data_atr(self.data[idx])} fn data_ival(&self, idx: usize) -> i32{parse_data_i32(self.data[idx])} fn data_uval(&self, idx: usize) -> u32{parse_data_u32(self.data[idx])}}"

    # wynn_item = "#[derive(Clone)]\npub struct WynnItem{item: &'static WynnItemData<'static>, pub dams: [(u16,u16); 6], pub skill_reqs: [i32;5], pub skill_boosts: [i32; 5]} impl WynnItem{pub fn null() -> WynnItem{WynnItem{item: items_list::ALL_ITEMS[0],dams:[(0_u16,0_u16);6],skill_reqs: [0;5],skill_boosts: [0;5]}} pub fn from(id: usize) -> WynnItem{let item = items_list::ALL_ITEMS[id];let mut dams:[(u16,u16);6]=[(0,0),(0,0),(0,0),(0,0),(0,0),(0,0)];let mut skill_reqs = [0,0,0,0,0]; let mut skill_boosts = [0,0,0,0,0]; for i in item.partitions.0..item.partitions.3{let atr = item.data_atr(i); match atr{"
    wynn_item = "#[derive(Clone)]\npub struct WynnItem{item: &'static WynnItemData<'static>, quality: f32} impl WynnItem{pub fn null() -> WynnItem{WynnItem{item: items_list::ALL_ITEMS[0], quality: 1.0}} pub fn from(idx: usize) -> WynnItem{let item = items_list::ALL_ITEMS[idx]; WynnItem{item: &items_list::ALL_ITEMS[idx],quality:1.0}}"
    # partition_start = order.index("strReq")
    # wynn_item+='|'.join([str(n) for n in range(partition_start,partition_start+5)])+f" => skill_reqs[(atr-{partition_start}) as usize]=item.data_ival(i),"
    # wynn_item+='|'.join([str(n) for n in range(partition_start+5,partition_start+10)])+f" => skill_boosts[(atr-{partition_start}-5) as usize]=item.data_ival(i),"
    # wynn_item+='|'.join([str(n) for n in range(partition_start+10,partition_start+16)])+f" => dams[(atr-{partition_start}-10) as usize]=((item.data_uval(i)&0xFFF) as u16,(item.data_uval(i)>>12) as u16),"
    # for atr in save_separately:
    #     idx = order.index(atr)
    #     if idx<partition_start+5:
    #         wynn_item+=f"{idx} => skill_reqs[{idx-partition_start}]=item.data_ival({idx}),"
    #     elif idx<partition_start+10:
    #         wynn_item+=f"{idx} => skill_boosts[{(idx-partition_start)%5}]=item.data_ival({idx}),"
    #     else:
    #         wynn_item+=f"{idx} => dams[{idx-partition_start-10}]=((item.data_uval({idx})&0xFFF) as u16,(item.data_uval({idx})>>12) as u16),"
    # wynn_item+="_ => break}}Self{item: &item, dams, skill_reqs, skill_boosts}}"

    wynn_item+="pub fn get_type(&self) -> Type{Type::from_u32(if self.is_null(){7}else{self.item.data_uval(0)}).unwrap_or(Type::Helmet)}"
    wynn_item+="pub fn get_category(&self) -> Category{Category::from_u32(if self.is_null(){0}else{self.item.data_uval("+str(order.index("category"))+")}).unwrap_or(Category::Armor)}"
    wynn_item+='pub fn is_null(&self) -> bool{self.item.data.is_empty()}'
    # wynn_item+="fn get_atr(&self, atr: Atrs)->Option<u32>{let atr_u32 = atr as u32; let idx = match self.item.data.binary_search(&((atr_u32)<<24)){Ok(v) => v, Err(v) => v}; if self.item.data[idx]>>24==atr_u32{Some(self.item.data[idx] & 0xFFFFFF)}else{None}}"
    wynn_item+='pub fn fixed_id(&self) -> bool{self.item.data.len()>='+str(order.index("fixID")+1)+'&&self.item.data_atr('+str(order.index("fixID"))+')=='+str(order.index("fixID"))+'}'
    wynn_item+="pub fn name(&self) -> &str{self.item.name}"
    wynn_item+="pub fn atk_spd(&self)->AtkSpd{if self.item.data_atr("+str(order.index("atkSpd")-1)+".min(self.item.data.len()-1))=="+str(order.index("atkSpd"))+"{AtkSpd::from_u32(self.item.data_uval("+str(order.index("atkSpd")-1)+")).unwrap_or(AtkSpd::Normal)}else if self.item.data_atr("+str(order.index("atkSpd"))+".min(self.item.data.len()-1))=="+str(order.index("atkSpd"))+"{AtkSpd::from_u32(self.item.data_uval("+str(order.index("atkSpd"))+")).unwrap_or(AtkSpd::Normal)}else{AtkSpd::Normal}}"
    wynn_item+="pub fn get_tier(&self)->Tier{Tier::from_u32(if self.is_null(){0}else{self.item.data_uval("+str(order.index("tier"))+")}).unwrap_or(Tier::Common)}"
    wynn_item+="fn calc_id(&self, idx: usize)->i32{let base_value = self.item.data_ival(idx); if self.fixed_id()||self.item.data_atr(idx)<="+str(order.index('aDef'))+"{base_value}else if base_value>0 {(base_value as f32*(self.quality+0.3)).round() as i32}else{(base_value as f32*((1.0-self.quality)*0.6+0.7)+4.000001*f32::EPSILON).round() as i32}}"
    wynn_item+="pub fn get_hash(&self) -> String{url_hash_val(self.item.data_ival("+str(order.index('id'))+"),3)}"
    wynn_item+="fn get_data_i32(&self, idx: usize) -> Option<(Atrs,i32)>{if idx>=self.item.data.len(){None}else{Some((Atrs::from_u32(self.item.data_atr(idx)).unwrap(),self.calc_id(idx)))}}"
    wynn_item+="pub fn get_ident(&self,ident: Atrs)->Option<i32>{let id_u32 = ident as u32; match self.item.data.binary_search(&(id_u32<<24)){Ok(n) => Some(self.calc_id(n)),Err(n) => if n>=self.item.data.len()||self.item.data_atr(n)!=id_u32{None}else{Some(self.calc_id(n))}}}"
    wynn_item+="pub fn get_set(&self)->Sets{if self.item.data_atr((self.item.partitions.0-1).min(self.item.data.len()-1))=="+str(order.index("set"))+"{Sets::from_u32(self.item.data_uval(self.item.partitions.0-1)).unwrap_or(Sets::None)}else{Sets::None}}"
    wynn_item+="pub fn set_quality(&mut self, qual: f32){self.quality=qual}"
    wynn_item+="pub fn iter_ids(&self) -> I32AtrsIter<'_>{I32AtrsIter{data:self.item.data,curr:self.item.partitions.3,end:self.item.data.len()}}"
    wynn_item+="pub fn iter_data(&self) -> I32AtrsIter<'_>{I32AtrsIter{data:self.item.data,curr:0,end:self.item.data.len()}}"
    wynn_item+="pub fn iter_skill_reqs(&self) -> I32AtrsIter<'_>{I32AtrsIter{data:self.item.data,curr:self.item.partitions.0,end:self.item.partitions.1}}"
    wynn_item+="pub fn iter_skill_bonus(&self) -> I32AtrsIter<'_>{I32AtrsIter{data:self.item.data,curr:self.item.partitions.1,end:self.item.partitions.2}}"
    wynn_item+="pub fn iter_damages(&self) -> DamsIter<'_>{DamsIter{item:self,curr:self.item.partitions.2,end:self.item.partitions.3}}"
    wynn_item+="\n/// Iterates over the skill requirements *and* skill bonuses for the item.\n///\n/// The iterator yields a tuple of the form (skill: Skill, requirement: i32, bonus: i32)\npub fn iter_skills(&self) -> SkillsIter<'_>{SkillsIter{item:self,req_idx:self.item.partitions.0,req_end_idx:self.item.partitions.1,bonus_idx:self.item.partitions.1,bonus_end_idx:self.item.partitions.2}}"
    wynn_item+="}"
    # wynn_build_struct = "#[derive(Default)]\npub struct WynnBuild{pub item_idxs: [usize; 9], pub sets_quant: Vec<(Sets,usize)>, pub skills: [i32; 5], pub dams: [(i32, i32); 6], pub "
    # wynn_build_struct += ", pub ".join([s[4::]+(": [i32; 5]" if s.endswith("defs") else ": [f32; 5]" if "def" in s else ": [f32; 6]") for s in ele_stats if s[4::] not in wynn_build_struct]) + ", pub "
    # wynn_build_struct += ", pub ".join([stats[id][1]+": "+'f32' if stats[id][2]=='i32' else stats[id][2] for id in ids if id not in ele_ids and id not in skill_bonuses])
    # wynn_build_struct+="} \nimpl WynnBuild{pub fn from_idxs(idxs: &[usize]) -> Option<WynnBuild>{let mut extra_skill_pts = 200; let mut skill_pts = [0,0,0,0,0];let mut max_reqs = [0,0,0,0,0]; let mut assigned_skills = [0,0,0,0,0]; let mut max_boost = [0,0,0,0,0]; for i in idxs.iter(){if *i==0_usize{continue} let item = items_list::ALL_ITEMS[*i];let req = item.get_reqs();let boosts = item.get_skill_bonuses();for (i,r) in req.iter().enumerate(){if max_reqs[i]<*r {max_reqs[i]=*r; max_boost[i]=boosts[i]}} for (i, b) in boosts.iter().enumerate(){skill_pts[i]+=b;}}for i in 0..5_usize{let diff = skill_pts[i]-max_boost[i]-max_reqs[i];if max_reqs[i]<=0 {continue} if diff<0{extra_skill_pts+=diff;skill_pts[i]-=diff+max_boost[i];assigned_skills[i]=-diff;}if extra_skill_pts<0 || -99>diff{return None}}let mut build = WynnBuild::default();build.skills=assigned_skills;for i in idxs.iter(){if *i!=0_usize{build.add_item(*i, 1.0, items_list::ALL_ITEMS[*i].props.contains(&Atrs::FixID(true)))}}Some(build)}"
    # wynn_build_struct+="pub fn add_item(&mut self, item_idx: usize, id_quality: f32, fixed: bool){let item = get(item_idx); self.item_idxs[8.min(item.get_type().to_num()+ if item.get_type()==Type::Ring && self.item_idxs[4]!=0 || item.get_type().to_num()>4 {1} else {0})]=item_idx; for id in item.ids{match id{"
    # for id in ids:
    #     stat = stats[id]
    #     if id in ["nDam","eDam","tDam","wDam","fDam","aDam"]:
    #         idx = ["nDam","eDam","tDam","wDam","fDam","aDam"].index(id)
    #         wynn_build_struct+=f"Atrs::{stat[0]}(n1,n2) => "+'{'+f"self.dams[{idx}].0+=*n1 as i32; self.dams[{idx}].1+=*n2 as i32"+'}, '
    #     elif id in ele_ids:
    #         idx = (dmg_types[1::] if "Def" in id else dmg_types).index(id[0])
    #         wynn_build_struct+=f"Atrs::{stat[0]}(n) => self.{stat[1][2::]+'s'}[{idx}]+={'n' if id.endswith('Def') else 'calc_id(*n,id_quality,fixed)'}, "
    #     elif id in skill_bonuses:
    #         idx = skill_bonuses.index(id)
    #         wynn_build_struct+=f"Atrs::{stat[0]}(n) => self.skills[{idx}]+=*n as i32,"
    #     else:
    #         wynn_build_struct+=f"Atrs::{stat[0]}(n) => self.{stat[1]}+={'n' if id.endswith('Def') else 'calc_id(*n,id_quality,fixed)'}, "
    # wynn_build_struct+="_ => ()}}match item.props.last().unwrap(){Atrs::Set(s) => for i in 0..self.sets_quant.len(){if s==&self.sets_quant[i].0{self.sets_quant[i].1+=1}},_ => ()}}}"
        
    limit = 10000
    wynn_items=[]
    for d in data['items']:
        struct_data = {}
        partitions = [0,0,0,0]
        for k, v in d.items():            
            if not k in stats or k=='set' or v=='0-0': continue
            if k=='tier' and (v=='Set' or d['name'] in get_set): # weird wonkyness because GM's boots? wtf is this item even?
                if d['name'] in get_set or d['displayName'] in get_set: struct_data['set']=(order.index('set')<<24)+enum_builder['sets'][1].index(get_set[d['name' if d['name'] in get_set else 'displayName']])
            stat = stats[k]
            struct_data[k]=(order.index(k)<<24)+((v if stat[2]=="i32" or stat[2]=="u32" else 1 if stat[2]=="bool" else enum_builder[k][0].index(capitalize(v[0]) if type(v)==list else capitalize(v)) if k in enum_builder else int(v.split('-')[0])+(int(v.split('-')[1])<<12) if stat[2]=="u16,u16" else 0)&0xFFFFFF)
        idx = 0
        num_props = 0
        partition_counter = [0,0,0]
        for x in order:
            if x in struct_data:
                if x in save_separately:
                    if num_props==0: num_props=idx
                    if x in save_separately[0:5]: partition_counter[0]+=1
                    elif x in save_separately[5:10]: partition_counter[1]+=1
                    elif x in save_separately[10:16]: partition_counter[2]+=1
                elif x in ids: break
                idx+=1
        if num_props==0: num_props=idx
        partitions[0]=num_props
        for i in range(len(partition_counter)):
            partitions[i+1]=partitions[i]+partition_counter[i]
        wynn_items.append('&super::WynnItemData{name: "'+d['displayName']+f'", sps_req_data: {compress_skills(get_skills(d, "Req", -1024))}, sps_bonus_data: {compress_skills(get_skills(d))}, partitions: ({",".join([str(n) for n in partitions])}), data: &['+','.join([str(struct_data[x]) for x in order if x in struct_data])+"]}")
        limit -= 1
        if limit<=0: break
    print(item_props)
    print(ids)
    # gen_items_func = "pub fn get_items_vec() -> Vec<WynnItem>{vec!["+',\n'.join(wynn_items)+"]}"
    iterators = "pub struct I32AtrsIter<'a>{data: &'a [u32], curr: usize, end: usize}impl Iterator for I32AtrsIter<'_>{type Item = (Atrs, i32);fn next(&mut self)->Option<Self::Item>{if self.curr>=self.end{return None}let res = (Atrs::from_u32(parse_data_atr(self.data[self.curr])).unwrap_or_default(),parse_data_i32(self.data[self.curr]));self.curr+=1;Some(res)}}"
    # iterators += "pub struct WynnItemIter<'a>{item: &'a WynnItem, curr: usize, end: usize}impl Iterator for WynnItemIter<'_>{type Item = (Atrs,i32);fn next(&mut self) -> Option<Self::Item>{if self.curr>=self.end{return None}; let res = self.item.get_data_i32(self.curr);self.curr+=1;res}}"
    iterators += "\npub struct DamsIter<'a>{item: &'a WynnItem, curr: usize, end: usize} impl Iterator for DamsIter<'_>{type Item = (DamType, (u32,u32)); fn next(&mut self) -> Option<Self::Item>{if self.curr>=self.end||self.curr>=self.item.item.data.len(){return None}; let dam_data = self.item.item.data[self.curr];let res = (DamType::from_u32(self.item.item.data_atr(self.curr)-"+str(order.index("nDam"))+").unwrap_or(DamType::Neutral),(dam_data&0xFFF,(dam_data&0xFFF000)>>12)); self.curr+=1; Some(res)}}"
    iterators += "\npub struct SkillsIter<'a>{item: &'a WynnItem, req_idx: usize, bonus_idx: usize, req_end_idx: usize, bonus_end_idx: usize}impl Iterator for SkillsIter<'_>{type Item = (Skill,i32,i32);fn next(&mut self) -> Option<Self::Item>{if self.req_idx>=self.req_end_idx&&self.bonus_idx>=self.bonus_end_idx{return None}; let req = if self.req_idx<self.item.item.data.len(){self.item.item.data_atr(self.req_idx)-"+str(order.index("strReq"))+"}else{6}; let bon=if self.bonus_idx<self.item.item.data.len(){self.item.item.data_atr(self.bonus_idx)-"+str(order.index("str"))+"}else{6}; let mut res = (Skill::from_u32(req.min(bon)).unwrap_or(Skill::Str),0,0); if req<bon{res.1=self.item.item.data_ival(self.req_idx); self.req_idx+=1;} else if req>bon{res.2=self.item.item.data_ival(self.bonus_idx); self.bonus_idx+=1;} else {res.1=self.item.item.data_ival(self.req_idx);self.req_idx+=1;res.2=self.item.item.data_ival(self.bonus_idx);self.bonus_idx+=1;}Some(res)}}"
    funcs = "pub fn iter() -> IntoIter<WynnItem>{items_list::ALL_ITEMS.iter().enumerate().map(|(idx, v)| WynnItem::from(idx)).collect::<Vec<WynnItem>>().into_iter()}"
    funcs += "pub fn get(idx: usize)->WynnItem{WynnItem::from(idx)}"
    funcs += "pub fn with_prop_value(prop: Atrs, value: u32) -> Vec<WynnItem>{let mut res: Vec<WynnItem> = Vec::new(); let prop_u32 = prop as u32; for (i,u) in items_list::ALL_ITEMS.iter().skip(1).enumerate(){let search = u.data.binary_search(&(prop_u32<<24)); let idx = match search{Ok(v) => v, Err(v) => v}; if u.data_atr(idx)==prop_u32 && u.data_uval(idx)==value {res.push(WynnItem::from(i+1))}} res}"
    funcs +="pub fn with_name(s: &str) -> Option<WynnItem>{let s_trimmed = s.trim(); for item in items_list::ALL_ITEMS.iter().enumerate(){if item.1.name.eq_ignore_ascii_case(s_trimmed){return Some(WynnItem::from(item.0))}}return None}"
    funcs+="pub fn calc_id(base_value: i32, roll_pct: f32, fixed: bool) -> i32{if fixed {base_value}else if base_value>0 {(base_value as f32*(roll_pct+0.3)).round() as i32}else{(base_value as f32*((1.0-roll_pct)*0.6+0.7)).round() as i32}}"
    funcs+="pub fn url_hash_val(val: i32, n: u8) -> String{let mut result = String::new();let mut local_val = val;for i in 0..n{result = String::from(DIGITS[(local_val & 0x3f) as usize]) + &result;local_val >>= 6;}result}"
    funcs+="pub fn get_set_bonuses(set: Sets, num_items: usize)->I32AtrsIter<'static>{let s = set as usize;I32AtrsIter{data:items_list::SET_BONUSES[s][num_items].1,curr:0,end:items_list::SET_BONUSES[s][num_items].1.len()}}"
    # funcs+="pub fn set_skill_bonuses(set: Sets, num_items: usize)->{let mut res = [0;5]; for (i,(a, v)) in get_set_bonuses(set, num_items).enumerate(){let a_usize = a as usize; if a_usize>"+order.index('agi')+"{break}else if a_usize>="+order.index('str')+"{res}}res}"

    gen_items_const = """pub const ALL_ITEMS: &'static[&'static super::WynnItemData] = &[&super::WynnItemData{name: "Invalid Item", sps_req_data: 0, sps_bonus_data: 0, partitions: (0,0,0,0), data:&[]},"""+',\n'.join(wynn_items)+"];"
    gen_set_bonuses_const = "pub const SET_BONUSES: &'static[&'static [(i64,&'static [u32])]] = &["+',\n'.join(set_bonuses)+"];"

    atrs_docs = "/// Used to identify almost all types of data stored in wynncraft items. \n///\n/// The following item attributes are ignored due to them either taking up a lot of memory or just not being useful for my application:\n/// - `drop`\n/// - `dropInfo`\n/// - `armorColor`\n/// - `skin`\n/// - `material` \n/// - `armorType`\n/// - `lore`\n/// - `quest`\n/// # Naming Convention\n/// **Attributes** - (Almost) all data stored in wynncraft items<br>\n/// **Properties** - Data intrinsic to items that don't get counted when calculating a build's stats. ie: `Type`, `Tier`, `ClassReq`, etc...<br>\n/// **Stats** - All data used for calculating a build's stats, including all *identifications*, hp, and ele defs. Damages, skill reqs, and skill bonuses are not included. <br>\n/// **Identifications** - All item *attributes* which are determined when identifying an item. These stats vary based on `WynnItem.quality`, unless `Atrs::FixID` is true. "
    generated_files_header = "//! This file is autogenerated by rs_generator.py.<br>Code in this file uses wynncraft item data from [wynnbuilder's github repo](https://raw.githubusercontent.com/hppeng-wynn/hppeng-wynn.github.io/dev/data/2.0.4.3/items.json)\n"

    enums_string.insert(0,"pub struct TryIntoWynnEnumError<F:std::fmt::Debug,T:WynnEnum>{from:F,to:T}impl <F:std::fmt::Debug,T:WynnEnum+std::default::Default> TryIntoWynnEnumError<F,T>{fn make(from: F) -> Self{Self{from, to: Default::default()}}}impl <F: std::fmt::Debug, T: WynnEnum> std::fmt::Debug for TryIntoWynnEnumError<F, T>{fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {write!(f,\"Could not convert {:#?} into {:#?}\", &self.from, std::any::type_name::<T>())}}")
    enums_string.insert(1,"pub trait WynnEnum{}")
    for i in range(len(enums_string)): 
        if "pub enum Atrs" in enums_string[-i-1]: 
            enums_string[-i-1]=f"{atrs_docs}\n{enums_string[-i-1]}" 
            break

    global tester
    tester=gen_items_const

    if not update: return

    # if not os.path.exists("src\\wynn_data"): os.mkdir("src\\wynn_data")
    if not os.path.exists("src\\wynn_data\\items"): os.mkdir("src\\wynn_data\\items")
    if not os.path.exists("src\\wynn_data\\enums"): os.mkdir("src\\wynn_data\\enums")
    # if not os.path.exists("src\\wynn_data\\builder"): os.mkdir("src\\wynn_data\\builder")
    if not os.path.exists("src\\wynn_data\\sets"): os.mkdir("src\\wynn_data\\sets")

    # writes to enums
    write_file('src\\wynn_data\\enums\\mod.rs',generated_files_header+"use core::fmt;mod convert_macro;use crate::enum_from_into;\n"+"\n".join(enums_string))
    
    # writes constant item data
    write_file('src\\wynn_data\\items\\items_list.rs',generated_files_header+gen_items_const)
    
    # writes constant set data
    write_file('src\\wynn_data\\sets\\set_bonus_data.rs',generated_files_header+gen_set_bonuses_const)
    
    # writes constants variables
    write_file('src\\wynn_data\\general\\consts.rs',generated_files_header+consts)
